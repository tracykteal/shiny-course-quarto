[
  {
    "objectID": "reactivity.html",
    "href": "reactivity.html",
    "title": "4  3: Reactivity essentials",
    "section": "",
    "text": "In this section we discuss reactivity in a bit more detail.\nThree components of reactive execution in Shiny are\n\nreactive inputs,\nreactive expressions, and\nreactive outputs.\n\nWe’re going to denote them with these symbols:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA reactive input is a user input that comes through a browser interface, typically.\nA reactive output is something that appears in the user’s browser window, such as a plot or a table of values.\nOne reactive input can be connected to multiple outputs, and vice versa. For example we might have a UI input widget for filtering out data based on user’s selection, and the filtered data can be used in multiple outputs like plots and summaries.\n\n\n\n\nA reactive expressions is component between an input and an output.\nIt can both be a dependent (i.e be a child) and have dependents (i.e. be a parent).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo illustrate reactivity we’re going to start with this app once again\n\n\n\n\n\n\n\n\n\n\n\n\nAnd end up with an app that…\n\nlets the user subset the data by movie type\nupdates the plot for those selected movie types\nand display some text noting the number of movies in the selection\n\n\n\n\n\n\n\n\n\n\nThe subsetted movies data frame gets used in two places, plot and text outputs. Hence, we we’re going to make use of reactive expressions to build this app.\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Select which types of movies to plot\nselectInput(\n  inputId = \"selected_type\",\n  label = \"Select movie type:\",\n  choices = levels(movies$title_type),\n  selected = \"Feature Film\"\n)\n\n\nWe define an inputId() that we’ll use to refer to the input element to later in the app\nWe come up with a user facing label\nWe specify the choices users can select from,\nas well as a default choice\n\n\n\n\nNext, we filter for selected title type and save the new data frame as a reactive expression using the reactive() function.\n\n\n\n\n\n\n\n\n\n\n# Create a subset of data filtering for chosen title types\nmovies_subset <- reactive({\n  req(input$selected_type)\n  filter(movies, title_type %in% input$selected_type)\n})\n\nThis function creates a cached expression that knows it is out of date when its input changes. So you, the Shiny developer, do not need to worry about keeping track of when the input changes, Shiny automatically does that for you.\nTwo more things to note here:\n\nBefore we do any calculations that depends on input$selected_type, we check its availability with the req() function, and\nWe surround the expression with curly braces\n\n\n\n\nThe next two steps could happen in either order. Let’s start with the plot first.\n\n\n\n\n\n\n\n\n\n\n# Create scatterplot\noutput$scatterplot <- renderPlot({\n  ggplot(data = movies_subset(),aes_string(x = input$x, y = input$y)) +\n    geom_point()\n})\n\nYou should be familiar with creating plots using the renderPlot() function by now. But there is something new here. The data frame we’re using is no longer movies, but the new reactive expression we created. And because it’s reactive we refer to it with parentheses after its name. This is, once again, a cached expression, meaning that it will only rerun when its inputs change.\n\n\n\n\n\n\n\n\n\n\n\n\nAnd lastly we create the text stating the number of observations in the selection. The obvious choice for creating this output would be renderText(). But I feel like getting a little fancier with this one. Suppose we know a bit of HTML – which is true, I really only know a bit of HTML – and I want to use some text decoration, like bolding and line breaks in my text output. So we need a rendering function that generates HTML, which is renderUI().\n\n# ui - Lay out where text should appear on app\nmainPanel( \n  ...\n  # Print number of obs plotted\n  uiOutput(outputId = \"n\"), \n  ...\n)\n\n\n# server - Print number of movies plotted\noutput$n <- renderUI({\n  HTML(paste0(\n    \"The plot displays the relationship between the <br>\n              audience and critics' scores of <br>\",\n    nrow(movies_subset()),\n    \" <b>\", input$selected_type, \"</b> movies.\"\n  ))\n})\n\nWe use the paste() function to string along the text of the sentence we want displayed on the app. This sentence depends on the value of the number of rows of the movies_subset reactive expression we created earlier, as well as input$selected type.\nUsing simple HTML we add some decoration to the text, and finally wrap the whole thing up in a function that marks the given text as HTML.\nThen on the ui side, we use the counterpart uiOutput() function to lay out the text on the app.\n\n\n\nWe ended the previous chapter with an app that allows you to download a data file with selected variables from the movies dataset. We will now extend this app by adding a table output of the selected data as well. Given that the same dataset will be used in two outputs, it makes sense to make our code more efficient by using a reactive data frame.\nExtend app by adding reactive data frame, which is a subset, that is used in the plot.\n\n\n\nDefine movies_selected: a reactive data frame consisting of selected variables (input$selected_var).\nUse the newly constructed movies_selected reactive data frame to avoid reconstructing the subsetted data frame multiple times throughout the app.\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 3-1 Add reactive data frame in your RStudio Workspace\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(dplyr)\nlibrary(readr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      radioButtons(\n        inputId = \"filetype\",\n        label = \"Select filetype:\",\n        choices = c(\"csv\", \"tsv\"),\n        selected = \"csv\"\n      ),\n\n      checkboxGroupInput(\n        inputId = \"selected_var\",\n        label = \"Select variables:\",\n        choices = names(movies),\n        selected = c(\"title\")\n      )\n    ),\n\n    mainPanel(\n      dataTableOutput(outputId = \"moviestable\"),\n      downloadButton(\"download_data\", \"Download data\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  # Create reactive data frame\n  movies_selected <- ___\n  \n  # Create data table\n  output$moviestable <- DT::renderDataTable({\n    req(input$selected_var)\n    datatable(\n      data = movies %>% select(input$selected_var),\n      options = list(pageLength = 10),\n      rownames = FALSE\n    )\n  })\n  \n  # Download file\n  output$download_data <- downloadHandler(\n    filename = function() {\n      paste0(\"movies.\", input$filetype)\n    },\n    content = function(file) {\n      if (input$filetype == \"csv\") {\n        write_csv(movies %>% select(input$selected_var), file)\n      }\n      if (input$filetype == \"tsv\") {\n        write_tsv(movies %>% select(input$selected_var), file)\n      }\n    }\n  )\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(dplyr)\nlibrary(readr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      radioButtons(\n        inputId = \"filetype\",\n        label = \"Select filetype:\",\n        choices = c(\"csv\", \"tsv\"),\n        selected = \"csv\"\n      ),\n\n      checkboxGroupInput(\n        inputId = \"selected_var\",\n        label = \"Select variables:\",\n        choices = names(movies),\n        selected = c(\"title\")\n      )\n    ),\n\n    mainPanel(\n      dataTableOutput(outputId = \"moviestable\"),\n      downloadButton(\"download_data\", \"Download data\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n\n  # Create reactive data frame\n  movies_selected <- reactive({\n    movies %>% select(input$selected_var)\n  })\n\n  # Create data table\n  output$moviestable <- DT::renderDataTable({\n    req(input$selected_var)\n    datatable(\n      data = movies_selected(),\n      options = list(pageLength = 10),\n      rownames = FALSE\n    )\n  })\n\n  # Download file\n  output$download_data <- downloadHandler(\n    filename = function() {\n      paste0(\"movies.\", input$filetype)\n    },\n    content = function(file) {\n      if (input$filetype == \"csv\") {\n        write_csv(movies_selected(), file)\n      }\n      if (input$filetype == \"tsv\") {\n        write_tsv(movies_selected(), file)\n      }\n    }\n  )\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "reactivity.html#using-reactives",
    "href": "reactivity.html#using-reactives",
    "title": "4  Reactivity essentials",
    "section": "4.2 3.2 Using reactives",
    "text": "4.2 3.2 Using reactives\nIn this section we discuss why we use reactives.\n\n4.2.1 Why use reactives?\nIn the previous exercises we were able to reuse our subsetted data frame in multiple places in the server after defining it once as a reactive expression.\nIn general, reactive expressions help you avoid copy-and-paste code and let you not repeat yourself, and they also help decompose large and complex calculations into smaller pieces.\nThese benefits are similar to what happens when you decompose a large complex R script into a series of small functions that build on each other\n\n\n4.2.2 Functions vs. reactives\nWhile functions and reactives help accomplish similar goals in terms of not-repeating oneself, they’re different in implementation.\n\nEach time you call a function, R will evaluate it.\nHowever reactive expressions are lazy, they only get executed when their input changes. This means that even if you call a reactive expression multiple times in your app, it will only re-execute when its inputs change.\n\n\n\n4.2.3 Reactlog\nUsing many reactive expressions in your app can create a complicated dependency structure in your app.\nThe reactlog is a graphical representation of this dependency structure, and it also gives you very detailed information about what’s happening under the hood as Shiny evaluates your application.\nTo view the reactlog:\n\nStart a fresh R session, and run options(shiny.reactlog = TRUE)\nThen launch your app as you normally would\nand in the app press Ctrl + F3 (or on a Mac: Cmd + F3).\n\n\n\n4.2.4 \nThe reactlog for the app we developed in the previous section looks like this. It uses the icons for reactive inputs, expressions, and outputs that we saw earlier in the course.\n\n\n\n\n\n\n\n\n\n\nOutputs are at the end of the reactive flow.\nInputs are at the beginning.\n\nmovies_subset() is a reactive expression in between the input and the outputs.\n\nThis visualization also makes it easy to view the inputs the reactive expression depends on and the output that depend on it.\n\n\n4.2.5 Practice - Find missing reactives\nIn the following app code there are a number of spots where reactives are not used properly.\n\n4.2.5.1 Your turn\nDebug the app, making sure reactives are being used correctly.\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 3-2a Find missing reactives in your RStudio Workspace\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tools)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  titlePanel(\"Movie browser\"),\n\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text for plot title\"\n      ),\n\n      checkboxGroupInput(\n        inputId = \"selected_type\",\n        label = \"Select movie type(s):\",\n        choices = c(\"Documentary\", \"Feature Film\", \"TV Movie\"),\n        selected = \"Feature Film\"\n      )\n    ),\n\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\"),\n      textOutput(outputId = \"description\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n\n  # Create a subset of data filtering for selected title types\n  movies_subset <- reactive({\n    req(input$selected_type)\n    filter(movies, title_type %in% input$selected_type)\n  })\n\n  # Convert plot_title toTitleCase\n  output$pretty_plot_title <- toTitleCase(input$plot_title)\n\n  # Create scatterplot object the plotOutput function is expecting\n  output$scatterplot <- renderPlot({\n    ggplot(\n      data = movies_subset,\n      aes_string(x = input$x, y = input$y, color = input$z)\n    ) +\n      geom_point() +\n      labs(title = pretty_plot_title)\n  })\n\n  # Create descriptive text\n  output$description <- renderText({\n    paste0(\"The plot above titled '\", pretty_plot_title, \"' visualizes the relationship between \", input$x, \" and \", input$y, \", conditional on \", input$z, \".\")\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tools)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  titlePanel(\"Movie browser\"),\n\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text for plot title\"\n      ),\n\n      checkboxGroupInput(\n        inputId = \"selected_type\",\n        label = \"Select movie type(s):\",\n        choices = c(\"Documentary\", \"Feature Film\", \"TV Movie\"),\n        selected = \"Feature Film\"\n      )\n    ),\n\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\"),\n      textOutput(outputId = \"description\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n\n  # Create a subset of data filtering for selected title types\n  movies_subset <- reactive({\n    req(input$selected_type)\n    filter(movies, title_type %in% input$selected_type)\n  })\n\n  # Convert plot_title toTitleCase\n  pretty_plot_title <- reactive({\n    toTitleCase(input$plot_title)\n  })\n\n  # Create scatterplot object the plotOutput function is expecting\n  output$scatterplot <- renderPlot({\n    ggplot(\n      data = movies_subset(),\n      aes_string(x = input$x, y = input$y, color = input$z)\n    ) +\n      geom_point() +\n      labs(title = pretty_plot_title())\n  })\n\n  # Create descriptive text\n  output$description <- renderText({\n    paste0(\"The plot above titled '\", pretty_plot_title(), \"' visualizes the relationship between \", input$x, \" and \", input$y, \", conditional on \", input$z, \".\")\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n4.2.6 Practice - Find inconsistencies in what the app is reporting\nIn this exercise we go on a hunt for mismatched used of reactives.\n\n4.2.6.1 Your turn\n\nRun the sample code and view the app. Do the number of movies plotted match the number cited in the text below the app?\nIf not, fix the app code.\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 3-2b Find inconsistencies in what the app is reporting in your RStudio Workspace\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      checkboxGroupInput(\n        inputId = \"selected_type\",\n        label = \"Select movie type(s):\",\n        choices = c(\"Documentary\", \"Feature Film\", \"TV Movie\"),\n        selected = \"Feature Film\"\n      ),\n\n      numericInput(\n        inputId = \"n_samp\",\n        label = \"Sample size:\",\n        min = 1, max = nrow(movies),\n        value = 3\n      )\n    ),\n\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\"),\n      uiOutput(outputId = \"n\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n\n  # Create a subset of data filtering for selected title types\n  movies_subset <- reactive({\n    req(input$selected_type)\n    filter(movies, title_type %in% input$selected_type)\n  })\n\n  # Create new df that is n_samp obs from selected type movies\n  movies_sample <- reactive({\n    req(input$n_samp)\n    sample_n(movies_subset(), input$n_samp)\n  })\n\n  # Create scatterplot object the plotOutput function is expecting\n  output$scatterplot <- renderPlot({\n    ggplot(data = movies_sample(), aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point()\n  })\n\n  # Print number of movies plotted\n  output$n <- renderUI({\n    types <- factor(movies_subset()$title_type, levels = input$selected_type)\n    counts <- table(types)\n    HTML(paste(\"There are\", counts, input$selected_type, \"movies plotted in the plot above. <br>\"))\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      checkboxGroupInput(\n        inputId = \"selected_type\",\n        label = \"Select movie type(s):\",\n        choices = c(\"Documentary\", \"Feature Film\", \"TV Movie\"),\n        selected = \"Feature Film\"\n      ),\n\n      numericInput(\n        inputId = \"n_samp\",\n        label = \"Sample size:\",\n        min = 1, max = nrow(movies),\n        value = 3\n      )\n    ),\n\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\"),\n      uiOutput(outputId = \"n\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n\n  # Create a subset of data filtering for selected title types\n  movies_subset <- reactive({\n    req(input$selected_type)\n    filter(movies, title_type %in% input$selected_type)\n  })\n\n  # Create new df that is n_samp obs from selected type movies\n  movies_sample <- reactive({\n    req(input$n_samp)\n    sample_n(movies_subset(), input$n_samp)\n  })\n\n  # Create scatterplot object the plotOutput function is expecting\n  output$scatterplot <- renderPlot({\n    ggplot(data = movies_sample(), aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point()\n  })\n\n  # Print number of movies plotted\n  output$n <- renderUI({\n    types <- movies_sample()$title_type %>%\n      factor(levels = input$selected_type)\n    counts <- table(types)\n    HTML(paste(\"There are\", counts, input$selected_type, \"movies plotted in the plot above. <br>\"))\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "reactivity.html#reactives-and-observers",
    "href": "reactivity.html#reactives-and-observers",
    "title": "4  Reactivity essentials",
    "section": "4.3 3.3 Reactives and observers",
    "text": "4.3 3.3 Reactives and observers\nIn this section we discuss implementations of the three different types of reactive objects.\n\n4.3.1 Reactive flow\nAs we go through the different implementations, I recommend that you think back to where they appear on the reactive flow chart.\n\n\n\n\n\n\n\n\n\n\n\n4.3.2 Reactive inputs\nAn implementation of reactive inputs is reactiveValues().\nOne example is user inputs (input$*). The input object is a reactive value that looks like a list, and contains many individual reactive values that are set by input from the web browser.\n\n\n4.3.3 Reactive expressions\nYou can create reactive expressions with the reactive() function.\nAn example is the reactive data frame subsets we created in the earlier sections and exercises.\n\nReactive expressions can access reactive values or other reactive expressions, and they return a value.\nThey are useful for caching the results of any procedure that happens in response to user input.\n\n\n\n4.3.4 Implementation of reactive outputs\nAnd lastly, the implementation for reactive outputs is observers.\nFor example, an output$* object is a reactive observer. Actually, under the hood a render function returns a reactive expression, and when you assign this reactive expression to an output$* value, Shiny automatically creates an observer that uses the reactive expression.\n\nObservers can access reactive inputs and reactive expressions, but they don’t return a value.\nInstead they are used for their side effects, which typically involves sending data to the web browser.\n\n\n\n4.3.5 Reactives vs. observers\nTo help these concepts sink in a bit more, let’s compare reactives vs. observers.\n\n4.3.5.1 Similarities\nBoth store expressions that can be executed\n\n\n4.3.5.2 Differences\n\nReactive expressions return values, but observers do not.\nObservers eagerly respond to reactives, but reactive expressions do not.\nReactive expressions must not have side effects, while observers are only useful for their side effects.\n\n\n\n4.3.5.3 Most importantly\n\nWe use the reactive() function when calculating values, without side effects.\nWe use the observe() function when performing actions, with side effects.\nThe moral of the story is to not use observe() when calculating a value, and to especially not use reactive() for performing actions with side effects.\n\n\n\n\n4.3.6 \nHere is a summary table of the differences between reactives and observers.\n\n\n\n\nreactive()\nobserve()\n\n\n\n\nPurpose\nCalculations\nActions\n\n\nSide effects\nForbidden\nAllowed\n\n\n\nA calculation is a block of code where you don’t care about whether the code actually executes—you just want the answer. Safe for caching. We use reactive() for these.\nAn action is where you care very much that the code executes, and there is no return value, there are only side effects. For these we use observe().\n\n\n4.3.7 Practice - Reactives vs. observers\nNext you get to assess your understanding of reactives vs. observers.\nYou’ll add a reactiveValues() element to the app. Define observers and their side effects, and how these compare to reactives.\n\n4.3.7.1 Your turn\nUsing the code from the app you worked on in the last exercise, add another reactiveValues() and reactiveVal() element to the app.\n\nComplete the exercise by building off of the code you completed in the last RStudio Cloud Project titled 3-2b Find inconsistencies in what the app is reporting in your RStudio Workspace\n Go to RStudio Cloud Project"
  },
  {
    "objectID": "reactivity.html#stop-trigger-delay",
    "href": "reactivity.html#stop-trigger-delay",
    "title": "4  Reactivity essentials",
    "section": "4.4 3.4 Stop-trigger-delay",
    "text": "4.4 3.4 Stop-trigger-delay\n\n4.4.1 \nIn this section we present how to stop, trigger, and delay Shiny actions.\n\n\n4.4.2 Isolating reactions\nSuppose your app has an input widget where users can enter text for the title of the plot. However you only want the title to update if any of the other inputs that go into the plot change. You can achieve this by isolating the plot title such that…\n\nWhen input$x or input$y changes, the plot, along with the title, will update.\nBut when only the title input (input$plot_title) changes, the plot will not update.\n\n\n\n\n\n\n\n\n\n\n\n\n4.4.3 Triggering reactions\nFor triggering reactions, we use observeEvent(). So why might one want to explicitly trigger a reaction?\nSometimes you might want to wait for a specific action to be taken from the user, like clicking an action button, before calculating an expression or taking an action. A reactive value or expression that is used to trigger other calculations in this way is called an event.\n\n\n\n\n\n\n\n\n\n\nThese events can be the first argument in the observeEvent() function. This argument can be a simple reactive value like an input, a call to a reactive expression, or a complex expression provided wrapped in curly braces.\nThe second argument is the expression to call whenever the first argument is invalidated.\n\nSo what you see here is similar to saying “if event expression happens, call handler expression”.\n\n\n4.4.4 \nSuppose your app allows for taking a random sample of the data based on a sample size numeric input. Suppose also that you want to add functionality for the users to download the random sample they generated if they press an action button (actionButton()) requesting to do so.\n\n\n\n\n\n\n\n\n\n\nIn the UI, we create an action button.\nAnd in the server, we condition the observeEvent() on the inputId of that action button. This way R knows to call the expression given in the second argument of observeEvent() when the user presses the action button.\n\n\n\n4.4.5 Delaying reactions\nAnd finally we can delay reactions with eventReactive(), which takes similar arguments as observeEvent().\n\n\n\n\n\n\n\n\n\n\n\n4.4.6 \nSuppose your goal is to change how users take random samples in your app – you only want them to get a new sample when an action button that says “get new sample” is pressed, not when other things like a numeric input defining the size of the sample changes.\n\n\n\n\n\n\n\n\n\n\nIn the eventReactive() function, the first argument is the input associated with the action button, and the second argument is the sampling code.\nThen, we add one more argument – ignoreNull. This argument tells R what to do (or what not to do) when the event expression evaluates to Null. For example, what should the app do when the app is first launched and the user has not even interacted with the app yet? If this is set to FALSE, the app will initially perform the action or calculation and then the user can re-initiate it.\n\n\n\n4.4.7 observeEvent() vs eventReactive()\nobserveEvent() and eventReactive() look and feel very similar – same syntax, same arguments, but they’re actually not the same at all!\n\nobserveEvent() is used to perform an action in response to an event\neventReactive() is used to create a calculated value that only updates in response to an event\n\n\n\n4.4.8 observeEvent()/eventReactive() vs. observe()/reactive()\nThis pair of functions also seem similar, at a first glance, to the observe/reactive pair, however the main difference between them is that\n\nobserve() and reactive() functions automatically trigger on whatever they access\nobserveEvent() and eventReactive() functions need to be explicitly told what triggers them\n\n\n\n4.4.9 isolate() vs event handling functions\nAnd where does isolate fit in all this?\n\nisolate() is used to stop a reaction\nobserveEvent() is used to perform an action in response to an event\neventReactive() is used to create a calculated value that only updates in response to an event\n\n\n\n4.4.10 Practice - Stop with isolate()\nIn the following app, the user, in addition to controlling which variables are plotted, can adjust the size and transparency of points and define the plot title.\n\n4.4.10.1 Your turn\n\nRun the code and test out the functionality of the plot title input. Is the plot title updated immediately after you’re done typing the title?\nModify the app so that the plot title only gets updated when one of the other inputs is changed.\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 3-4a Stop with isolate() in your RStudio Workspace\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(tools)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.5\n      ),\n\n      sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 2\n      ),\n\n      textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      )\n    ),\n\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point(alpha = input$alpha, size = input$size) +\n      labs(title = toTitleCase(input$plot_title))\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(tools)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.5\n      ),\n\n      sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 2\n      ),\n\n      textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      )\n    ),\n\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point(alpha = input$alpha, size = input$size) +\n      labs(title = isolate({\n        toTitleCase(input$plot_title)\n      }))\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n4.4.11 Practice - Delay with eventReactive()\nThe following app has the same starter code as the previous exercise.\n\n4.4.11.1 Your turn\nModify the app such that the title is updated only when a button titled “Update plot title” is clicked.\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 3-4b Delay with eventReactive() in your RStudio Workspace\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(tools)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.5\n      ),\n\n      sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 2\n      ),\n\n      textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      )\n    ),\n\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point(alpha = input$alpha, size = input$size) +\n      labs(title = toTitleCase(input$plot_title))\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(tools)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.5\n      ),\n\n      sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 2\n      ),\n\n      textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      ),\n\n      actionButton(\n        inputId = \"update_plot_title\",\n        label = \"Update plot title\"\n      )\n    ),\n\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  new_plot_title <- eventReactive(\n    eventExpr = input$update_plot_title,\n    valueExpr = {\n      toTitleCase(input$plot_title)\n    }\n  )\n\n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point(alpha = input$alpha, size = input$size) +\n      labs(title = new_plot_title())\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n4.4.12 Practice - Trigger with observeEvent()\nIn this app we want two things to happen when an action button is clicked:\n\nA message printed to the console stating how many records are shown and\nA table output of those records.\n\n\n4.4.12.1 Your turn\n\nFill in the necessary function and input ID for printing a message to the console when the action button is clicked.\nSet up a table output that will print only when action button is clicked, but not when other inputs that go into the creation of that output changes.\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 3-4c Trigger with observeEvent() in your RStudio Workspace\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      numericInput(\n        inputId = \"n_rows\",\n        label = \"How many rows do you want to see?\",\n        value = 10\n      ),\n\n      actionButton(\n        inputId = \"button\",\n        label = \"Show\"\n      )\n    ),\n\n    mainPanel(\n      tableOutput(outputId = \"datatable\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n\n  # Print a message to the console every time button is pressed;\n  ___(input$___, {\n    cat(\"Showing\", input$n_rows, \"rows\\n\")\n  })\n  \n  # Take a reactive dependency on input$button, but not on any other inputs\n  df <- ___(input$___, {\n    head(movies, input$n_rows)\n  })\n  output$___ <- ___({\n    df()\n  })\n  \n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      numericInput(\n        inputId = \"n_rows\",\n        label = \"How many rows do you want to see?\",\n        value = 10\n      ),\n\n      actionButton(\n        inputId = \"button\",\n        label = \"Show\"\n      )\n    ),\n\n    mainPanel(\n      tableOutput(outputId = \"datatable\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n\n  # Pring a message to the console every time button is pressed;\n  observeEvent(input$button, {\n    cat(\"Showing\", input$n_rows, \"rows\\n\")\n  })\n\n  # Take a reactive dependency on input$button,\n  # but not on any of the stuff inside the function\n  df <- eventReactive(input$button, {\n    head(movies, input$n_rows)\n  })\n  output$datatable <- renderTable({\n    df()\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n4.4.13 Practice - Difference between eventReactive() and observeEvent()\nWhich of the following is false?\n#{r mc-3, echo=FALSE} #question(\"Which of the following is false?\", #  answer(\"`observeEvent()` is used to perform an action in response to an event\"), #  answer(\"`isolate()` is used to trigger a reaction\", correct = TRUE), #  answer(\"`eventReactive()` is used to create a calculated value that only updates in response to an event\"), #  answer(\"Recalculating a value does not generally count as performing an action\"), #  allow_retry = TRUE #) #"
  },
  {
    "objectID": "reactivity.html#reactive-recap",
    "href": "reactivity.html#reactive-recap",
    "title": "4  Reactivity essentials",
    "section": "4.5 3.5 Reactive Recap",
    "text": "4.5 3.5 Reactive Recap\n\n4.5.1 \nLet’s recap what we have learned about reactivity and discuss best practices.\n\n\n4.5.2 Three Lessons\nThere are three main takeaway messages about reactivity that all Shiny developers should be familiar with.\n\nReactives are like functions, but they are lazily evaluated, meaning they will only evaluate when their inputs change, not each time they are called.\nReactive inputs and expressions are for their values and observers are for their side effects.\nDo not define a reactive() inside a render*() function.\n\n\n\n4.5.3 What’s wrong?\nWe’ll wrap up the chapter with a simple but important example.\nHere we have an app that adds 2 to the current value of x.\n\nlibrary(shiny)\n\nui <- fluidPage(\n  titlePanel(\"Add 2\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"x\", \"Select x\", min = 1, max = 50, value = 30)\n    ),\n    mainPanel(textOutput(\"x_updated\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  add_2 <- function(x) {\n    x + 2\n  }\n  current_x <- add_2(input$x)\n  output$x_updated <- renderText({\n    current_x\n  })\n}\n\nshinyApp(ui, server)\n\n\n\n4.5.4 \nHere is what the app should look like:\n\n\n\n\n\n\n\n\n\n\n\n4.5.5 \nAnd here again is the code. What’s wrong here?\n\nlibrary(shiny)\n\nui <- fluidPage(\n  titlePanel(\"Add 2\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"x\", \"Select x\", min = 1, max = 50, value = 30)\n    ),\n    mainPanel(textOutput(\"x_updated\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  add_2 <- function(x) {\n    x + 2\n  }\n  current_x <- add_2(input$x)\n  output$x_updated <- renderText({\n    current_x\n  })\n}\n\nshinyApp(ui, server)\n\n\n\n4.5.6 \nThe object current_x is used in the render function, but it’s not currently a reactive expression.\n\n\n4.5.7 \nSo we need to put the definition of current_x in the reactive function, like this:\n\nlibrary(shiny)\n\nui <- fluidPage(\n  titlePanel(\"Add 2\"),\n  sidebarLayout(\n    sidebarPanel(sliderInput(\"x\", \"Select x\", min = 1, max = 50, value = 30)),\n    mainPanel(textOutput(\"x_updated\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  add_2 <- function(x) {\n    x + 2\n  }\n  current_x <- reactive({\n    add_2(input$x)\n  })\n  output$x_updated <- renderText({\n    current_x\n  })\n}\n\nshinyApp(ui, server)\n\nBut that’s still not enough…\n\n\n4.5.8 \nWe also need to refer to current_x with parantheses after its name.\n\nlibrary(shiny)\n\nui <- fluidPage(\n  titlePanel(\"Add 2\"),\n  sidebarLayout(\n    sidebarPanel(sliderInput(\"x\", \"Select x\", min = 1, max = 50, value = 30)),\n    mainPanel(textOutput(\"x_updated\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  add_2 <- function(x) {\n    x + 2\n  }\n  current_x <- reactive({\n    add_2(input$x)\n  })\n  output$x_updated <- renderText({\n    current_x()\n  })\n}\n\nshinyApp(ui, server)\n\nMissing the parentheses is a common error when working with reactives. So add this to your list! When developing Shiny apps, be wary of missing commas, and of missing parentheses when calling reactive expressions.\n\n\n4.5.9 Practice - What’s wrong?\n\n4.5.9.1 Your turn\nWhat’s wrong with this? Fix it.\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 3-5 Whats wrong in your RStudio Workspace\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  titlePanel(\"Multiply by 3\"),\n  sidebarLayout(\n    sidebarPanel(sliderInput(\"x\", \"Select x\", min = 1, max = 50, value = 30)),\n    mainPanel(textOutput(\"x_updated\"))\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  mult_3 <- function(x) {\n    x * 3\n  }\n  output$x_updated <- mult_3(input$x)\n  \n}\n\n# Create the Shiny app ---------------------------------------------------------\nshinyApp(ui, server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  titlePanel(\"Multiply by 3\"),\n  sidebarLayout(\n    sidebarPanel(sliderInput(\"x\", \"Select x\", min = 1, max = 50, value = 30)),\n    mainPanel(textOutput(\"x_updated\"))\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  mult_3 <- function(x) {\n    x * 3\n  }\n  current_x <- reactive({\n    mult_3(input$x)\n  })\n  output$x_updated <- renderText({\n    current_x()\n  })\n}\n\n# Create the Shiny app ---------------------------------------------------------\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "reactivity.html#reactive-elements",
    "href": "reactivity.html#reactive-elements",
    "title": "4  Reactivity essentials",
    "section": "4.1 3.1 Reactive elements",
    "text": "4.1 3.1 Reactive elements\n\n4.1.1 Reactive objects\nIn this section we discuss reactivity in a bit more detail.\nThree components of reactive execution in Shiny are\n\nreactive inputs,\nreactive expressions, and\nreactive outputs.\n\nWe’re going to denote them with these symbols:\n\n\n\n\n\n\n\n\n\n\n\n4.1.2 Reactive inputs and outputs\n\n\n\n\n\n\n\n\n\n\nA reactive input is a user input that comes through a browser interface, typically.\nA reactive output is something that appears in the user’s browser window, such as a plot or a table of values.\nOne reactive input can be connected to multiple outputs, and vice versa. For example we might have a UI input widget for filtering out data based on user’s selection, and the filtered data can be used in multiple outputs like plots and summaries.\n\n\n\n4.1.3 Reactive expressions\nA reactive expressions is component between an input and an output.\nIt can both be a dependent (i.e be a child) and have dependents (i.e. be a parent).\n\n\n\n\n\n\n\n\n\n\n\n4.1.4 Practice\nWhich of the following is false?\n#``{r mc-1, echo=FALSE} #question(“Which of the following is false? Select all that apply.”, # answer(“Reactive inputs can only be parents.”), # answer(“Reactive inputs can only be children.”, correct = TRUE), # answer(“Reactive expressions can be parents.”), # answer(“Reactive expressions can be children.”), # answer(“Reactive outputs can be parents.”, correct = TRUE), # answer(“Reactive outputs can be children”), # allow_retry = TRUE #) #```\n\n\n4.1.5 \nTo illustrate reactivity we’re going to start with this app once again\n\n\n\n\n\n\n\n\n\n\n\n4.1.6 \nAnd end up with an app that…\n\nlets the user subset the data by movie type\nupdates the plot for those selected movie types\nand display some text noting the number of movies in the selection\n\n\n\n\n\n\n\n\n\n\nThe subsetted movies data frame gets used in two places, plot and text outputs. Hence, we we’re going to make use of reactive expressions to build this app.\n\n\n4.1.7 1. ui: Add a UI element for the user to select which movie type(s) of moves they want to plot with selectInput().\n\n\n\n\n\n\n\n\n\n\n# Select which types of movies to plot\nselectInput(\n  inputId = \"selected_type\",\n  label = \"Select movie type:\",\n  choices = levels(movies$title_type),\n  selected = \"Feature Film\"\n)\n\n\nWe define an inputId() that we’ll use to refer to the input element to later in the app\nWe come up with a user facing label\nWe specify the choices users can select from,\nas well as a default choice\n\n\n\n4.1.8 2. server: Filter for chosen title type and save the new data frame as a reactive expression.\nNext, we filter for selected title type and save the new data frame as a reactive expression using the reactive() function.\n\n\n\n\n\n\n\n\n\n\n# Create a subset of data filtering for chosen title types\nmovies_subset <- reactive({\n  req(input$selected_type)\n  filter(movies, title_type %in% input$selected_type)\n})\n\nThis function creates a cached expression that knows it is out of date when its input changes. So you, the Shiny developer, do not need to worry about keeping track of when the input changes, Shiny automatically does that for you.\nTwo more things to note here:\n\nBefore we do any calculations that depends on input$selected_type, we check its availability with the req() function, and\nWe surround the expression with curly braces\n\n\n\n4.1.9 3. server: Use movies_subset (which is reactive) for plotting.\nThe next two steps could happen in either order. Let’s start with the plot first.\n\n\n\n\n\n\n\n\n\n\n# Create scatterplot\noutput$scatterplot <- renderPlot({\n  ggplot(data = movies_subset(),aes_string(x = input$x, y = input$y)) +\n    geom_point()\n})\n\nYou should be familiar with creating plots using the renderPlot() function by now. But there is something new here. The data frame we’re using is no longer movies, but the new reactive expression we created. And because it’s reactive we refer to it with parentheses after its name. This is, once again, a cached expression, meaning that it will only rerun when its inputs change.\n\n\n4.1.10 3. ui & server: Use movies_subset (which is reactive) for printing number of observations.\n\n\n\n\n\n\n\n\n\nAnd lastly we create the text stating the number of observations in the selection. The obvious choice for creating this output would be renderText(). But I feel like getting a little fancier with this one. Suppose we know a bit of HTML – which is true, I really only know a bit of HTML – and I want to use some text decoration, like bolding and line breaks in my text output. So we need a rendering function that generates HTML, which is renderUI().\n\n# ui - Lay out where text should appear on app\nmainPanel( \n  ...\n  # Print number of obs plotted\n  uiOutput(outputId = \"n\"), \n  ...\n)\n\n\n# server - Print number of movies plotted\noutput$n <- renderUI({\n  HTML(paste0(\n    \"The plot displays the relationship between the <br>\n              audience and critics' scores of <br>\",\n    nrow(movies_subset()),\n    \" <b>\", input$selected_type, \"</b> movies.\"\n  ))\n})\n\nWe use the paste() function to string along the text of the sentence we want displayed on the app. This sentence depends on the value of the number of rows of the movies_subset reactive expression we created earlier, as well as input$selected type.\nUsing simple HTML we add some decoration to the text, and finally wrap the whole thing up in a function that marks the given text as HTML.\nThen on the ui side, we use the counterpart uiOutput() function to lay out the text on the app.\n\n\n4.1.11 Practice - Add reactive data frame\nWe ended the previous chapter with an app that allows you to download a data file with selected variables from the movies dataset. We will now extend this app by adding a table output of the selected data as well. Given that the same dataset will be used in two outputs, it makes sense to make our code more efficient by using a reactive data frame.\nExtend app by adding reactive data frame, which is a subset, that is used in the plot.\n\n4.1.11.1 Your turn\n\nDefine movies_selected: a reactive data frame consisting of selected variables (input$selected_var).\nUse the newly constructed movies_selected reactive data frame to avoid reconstructing the subsetted data frame multiple times throughout the app.\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 3-1 Add reactive data frame in your RStudio Workspace\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(dplyr)\nlibrary(readr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      radioButtons(\n        inputId = \"filetype\",\n        label = \"Select filetype:\",\n        choices = c(\"csv\", \"tsv\"),\n        selected = \"csv\"\n      ),\n\n      checkboxGroupInput(\n        inputId = \"selected_var\",\n        label = \"Select variables:\",\n        choices = names(movies),\n        selected = c(\"title\")\n      )\n    ),\n\n    mainPanel(\n      dataTableOutput(outputId = \"moviestable\"),\n      downloadButton(\"download_data\", \"Download data\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  # Create reactive data frame\n  movies_selected <- ___\n  \n  # Create data table\n  output$moviestable <- DT::renderDataTable({\n    req(input$selected_var)\n    datatable(\n      data = movies %>% select(input$selected_var),\n      options = list(pageLength = 10),\n      rownames = FALSE\n    )\n  })\n  \n  # Download file\n  output$download_data <- downloadHandler(\n    filename = function() {\n      paste0(\"movies.\", input$filetype)\n    },\n    content = function(file) {\n      if (input$filetype == \"csv\") {\n        write_csv(movies %>% select(input$selected_var), file)\n      }\n      if (input$filetype == \"tsv\") {\n        write_tsv(movies %>% select(input$selected_var), file)\n      }\n    }\n  )\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(dplyr)\nlibrary(readr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      radioButtons(\n        inputId = \"filetype\",\n        label = \"Select filetype:\",\n        choices = c(\"csv\", \"tsv\"),\n        selected = \"csv\"\n      ),\n\n      checkboxGroupInput(\n        inputId = \"selected_var\",\n        label = \"Select variables:\",\n        choices = names(movies),\n        selected = c(\"title\")\n      )\n    ),\n\n    mainPanel(\n      dataTableOutput(outputId = \"moviestable\"),\n      downloadButton(\"download_data\", \"Download data\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n\n  # Create reactive data frame\n  movies_selected <- reactive({\n    movies %>% select(input$selected_var)\n  })\n\n  # Create data table\n  output$moviestable <- DT::renderDataTable({\n    req(input$selected_var)\n    datatable(\n      data = movies_selected(),\n      options = list(pageLength = 10),\n      rownames = FALSE\n    )\n  })\n\n  # Download file\n  output$download_data <- downloadHandler(\n    filename = function() {\n      paste0(\"movies.\", input$filetype)\n    },\n    content = function(file) {\n      if (input$filetype == \"csv\") {\n        write_csv(movies_selected(), file)\n      }\n      if (input$filetype == \"tsv\") {\n        write_tsv(movies_selected(), file)\n      }\n    }\n  )\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n4.1.12 Practice: Identify reactive objects\nThe movies_selected() reactive expression from the previous exercise is a…\n#{r mc-2, echo=FALSE} #question(\"The `movies_selected()` reactive expression from the previous exercise is a...\", #  answer(\"Reactive input\"), #  answer(\"Reactive expression\", correct = TRUE), #  answer(\"Reactive output\"), #  answer(\"Reactive paradigm\"), #  allow_retry = TRUE, #  try_again = \"Try again -- does it have children? Does it have parents? Does it have both?\" #) #"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "This tutorial comprised of four modules will introduce you to Shiny, the R package for building interactive web apps straight from R."
  },
  {
    "objectID": "intro.html#what-youll-learn",
    "href": "intro.html#what-youll-learn",
    "title": "Introduction",
    "section": "What you’ll learn",
    "text": "What you’ll learn\nIn this module, we’ll begin by introducing the basics of Shiny.\nSo, let’s get to it…"
  },
  {
    "objectID": "hello.html",
    "href": "hello.html",
    "title": "1  Getting Started",
    "section": "",
    "text": "And not just any app, an app that you will be able to build by the end of this tutorial!\n\n\n\n\n\nhttps://minecr.shinyapps.io/movies/?showcase=0\n\n\n1200px\n\n\nhttps://minecr.shinyapps.io/movies/\n\n\nWe’ll go through the technical details of each component of such an app throughout the tutorial, but for now let’s take a high level view.\n\n\n\n\n\n\n\n\n\nWe have:\n\na title for the app,\na series of inputs:\n\nsome of these inputs use drop down menus for selection,\nsome are sliders,\nsome allow for text input, and\nsome are action buttons\n\nand a few outputs:\n\na plot output that the user can interactively update,\na text output that updates alongside it, and\na data table output that also updates alongside these.\n\n\nAs much as it looks like there is a lot going on in this sample app, the app doesn’t even scratch the surface of what you can build with Shiny.\nI hope you’re excited to take it all in!"
  },
  {
    "objectID": "hello.html#user-interface-ui",
    "href": "hello.html#user-interface-ui",
    "title": "1  Getting Started",
    "section": "1.11 User interface (UI)",
    "text": "1.11 User interface (UI)\n\n1.11.1 \nIn this section we’ll build the user interface of a simple app.\nHowever, before we get into the weeds of building a user interface, let’s revisit the anatomy of a Shiny app.\n\n\n\n\n\n\n\n\n\n\nThe user interface, that we’ll refer to as the “UI” going forward, defines and lays out the inputs of your app where users can make their selections. It also lays out the outputs.\nThe server function, on the other hand, calculates outputs and performs any other calculations needed for the outputs.\n\n\n\n1.11.2 Example\n\n\n\n\n\n\n\n\n\nFor example, if your app features a plot the code for building that plot lives in the server function. But the setup for the user defined inputs for the plot, as well as information on where physically on the app the plot should appear, are defined in the UI.\n\n\n1.11.3 \nHere is the app we’ll work with in this section and the code that builds the UI of that app.\nSince this is too much code to parse, we’ll explore individual components of the UI one by one.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.11.4 fluidPage()\nAt the outermost layer of our UI definition we begin with the fluidPage() function.\n\n\n\n\n\n\n\n\n\nThe fluidPage() function creates a fluid page layout consisting of rows and columns. Rows make sure that elements in them appear on the same line. Columns within these rows define how much horizontal space each element should occupy.\nFluid pages scale their components in realtime to fill all available browser width, which means you, the app developer, don’t need to worry about defining relative widths for individual app components.\nAs always, for more information on arguments to this function, you can view the R function help by typing ?fluidPage in your R console or visiting the function reference page on the package website here.\n\n\n1.11.5 Layout\nNext, we define the layout of our app with sidebarLayout().\n\n\n\n\n\n\n\n\n\nShiny includes a number of options for laying out the components of an application. The default layout, the one we’re using in our example app, is a layout with a sidebar, that you can define with the sidebarLayout() function.\n\n\n\n\n\n\n\n\n\nThis is a simple layout with a narrow sidebar for inputs and a wider main area for output.\nUnder the hood, Shiny implements layout features available in Bootstrap 2, which is a popular HTML/CSS framework. However the nice thing about working in Shiny is that no prior experience with Bootstrap is necessary.\nTo learn more about various layouts, I recommend reviewing the Application Layout Guide article at shiny.rstudio.com.\n\n\n1.11.6 Input controls\nNext we define our sidebar panel containing input controls.\n\n\n\n\n\n\n\n\n\n\n\n1.11.7 \nThis panel contains two dropdown menus created with the selectInput() function.\n\n\n\n\n\n\n\n\n\n\n\n1.11.8 \nLet’s take a look at one of the selectInput widgets a little more closely.\n\n\n\n\n\n\n\n\n\n\nThe first argument is the inputId, which is the input value that the app will internally use to access the value selected by the user.\nThe second argument is the label, which is the display label that the user sees.\nThe third argument is the list of choices the user will choose from. In this app, these are variable names from the movies dataset.\nAnd lastly we specify a default selection from that list with selected.\n\n\n\n1.11.9 Main Panel\nThe final component of our UI is mainPanel().\n\n\n\n\n\n\n\n\n\nCurrently the main panel contains only one component, a plot output. We’ll talk about how this plot is built later in the tutorial.\nNext, let’s practice building an app UI!\n\n\n1.11.10 Practice: Extend the UI\nWe’ll start with a simplified version of the app you saw in the previous exercise. In this app a selectInput() widget is used to allow the user to select which variables should be plotted on the x and y axes of the scatterplot.\nThe selectInput() function has the following arguments:\n\nan inputId that is used to refer to the input parameter when building the scatterplot,\na list of choices to pick from (which must match variable names in the data frame),\nand a selected choice for when the app first launches.\n\n\n1.11.10.1 Your turn\nModify the Shiny app code in app.R / shown below:\n\nIn the ui:\n\nAdd a new selectInput widget to color the points by a choice of the following variables: \"title_type\", \"genre\", \"mpaa_rating\", \"critics_rating\", \"audience_rating\".\nMake the default selection \"mpaa_rating\".\nUse \"z\" as the inputId.\nlabel can be whatever you like.\n\nIn the server:\n\nSet the color argument in ggplot() aesthetic mappings to input$z.\n\n\n\nComplete this exercise by opening up the RStudio Project titled 1-2a Extend the UI within your RStudio Cloud Workspace\n Go to RStudio Cloud Workspace\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  \n  sidebarLayout(\n    \n    # Inputs: Select variables to plot\n    sidebarPanel(\n      \n      # Select variable for y-axis\n      selectInput(inputId = \"y\", \n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"), \n                  selected = \"audience_score\"),\n      \n      # Select variable for x-axis\n      selectInput(inputId = \"x\", \n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"), \n                  selected = \"critics_score\"),\n      \n      # Select variable for color\n      selectInput(inputId = \"___\", \n                  label = \"____\",\n                  choices = c(___),\n                  selected = \"___\")\n      \n    ),\n    \n    # Output: Show scatterplot\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y,\n                                     color = ___)) +\n      geom_point()\n  })\n  \n  }\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  \n  sidebarLayout(\n    \n    # Inputs: Select variables to plot\n    sidebarPanel(\n      \n      # Select variable for y-axis\n      selectInput(inputId = \"y\", \n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"), \n                  selected = \"audience_score\"),\n      \n      # Select variable for x-axis\n      selectInput(inputId = \"x\", \n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"), \n                  selected = \"critics_score\"),\n      \n      # Select variable for color\n      selectInput(inputId = \"z\", \n                  label = \"Color by:\",\n                  choices = c(\"title_type\", \"genre\", \"mpaa_rating\", \"critics_rating\", \"audience_rating\"),\n                  selected = \"mpaa_rating\")\n      \n    ),\n    \n    # Output: Show scatterplot\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y,\n                                     color = input$z)) +\n      geom_point()\n  })\n  \n  }\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n1.11.11 Practice: Extend the UI further\nThe potential variables the user can select for the x and y axes and color currently appear in the UI of the app the same way that they are spelled in the data frame header. However we might want to label them in a way that is more human readable. We can achieve this using named vectors for the choices argument, in the format of \"Human readable label\" = \"variable_name\".\n\n1.11.11.1 Your turn\n\nFill in the blanks in the code below with human readable labels for x and y inputs.\nRe-create the selectInput widget for color, z, with options \"title_type\", \"genre\", \"mpaa_rating\", \"critics_rating\", and \"audience_rating\", default selection \"mpaa_rating\" just like in the previous exercise, but this time use human readable labels as well.\n\n\nComplete this exercise by opening up the RStudio Project titled 1-2b Extend the UI further within your RStudio Cloud Workspace\n Go to RStudio Cloud Workspace\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  \n  sidebarLayout(\n    \n    # Inputs: Select variables to plot\n    sidebarPanel(\n      \n      # Select variable for y-axis\n      selectInput(inputId = \"y\", \n                  label = \"Y-axis:\",\n                  choices = c(___ = \"imdb_rating\", \n                              ___ = \"imdb_num_votes\", \n                              ___ = \"critics_score\", \n                              ___ = \"audience_score\", \n                              ___ = \"runtime\"), \n                  selected = \"audience_score\"),\n      \n      # Select variable for x-axis\n      selectInput(inputId = \"x\", \n                  label = \"X-axis:\",\n                  choices = c(___ = \"imdb_rating\", \n                              ___ = \"imdb_num_votes\", \n                              ___ = \"critics_score\", \n                              ___ = \"audience_score\", \n                              ___ = \"runtime\"), \n                  selected = \"critics_score\"),\n      \n      # Select variable for color\n      selectInput(inputId = \"z\", \n                  label = \"Color:\",\n                  choices = ___, \n                  selected = ___)\n      \n    ),\n    \n    # Output: Show scatterplot\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y,\n                                     color = input$z)) +\n      geom_point()\n  })\n  \n  }\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  \n  sidebarLayout(\n    \n    # Inputs: Select variables to plot\n    sidebarPanel(\n      \n      # Select variable for y-axis\n      selectInput(inputId = \"y\", \n                  label = \"Y-axis:\",\n                  choices = c(\"IMDB rating\"          = \"imdb_rating\", \n                              \"IMDB number of votes\" = \"imdb_num_votes\", \n                              \"Critics score\"        = \"critics_score\", \n                              \"Audience score\"       = \"audience_score\", \n                              \"Runtime\"              = \"runtime\"), \n                  selected = \"audience_score\"),\n      \n      # Select variable for x-axis\n      selectInput(inputId = \"x\", \n                  label = \"X-axis:\",\n                  choices = c(\n                    \"IMDB rating\"          = \"imdb_rating\", \n                    \"IMDB number of votes\" = \"imdb_num_votes\", \n                    \"Critics score\"        = \"critics_score\", \n                    \"Audience score\"       = \"audience_score\", \n                    \"Runtime\"              = \"runtime\"), \n                  selected = \"critics_score\"),\n      \n      # Select variable for color\n      # Select variable for color\n      selectInput(inputId = \"z\", \n                  label = \"Color by:\",\n                  choices = c(\n                    \"Title type\" = \"title_type\", \n                    \"Genre\" = \"genre\", \n                    \"MPAA rating\" = \"mpaa_rating\", \n                    \"Critics rating\" = \"critics_rating\", \n                    \"Audience rating\" = \"audience_rating\"),\n                  selected = \"mpaa_rating\")\n      \n    ),\n    \n    # Output: Show scatterplot\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y,\n                                     color = input$z)) +\n      geom_point()\n  })\n  \n  }\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "hello.html#server-function",
    "href": "hello.html#server-function",
    "title": "1  Getting Started",
    "section": "1.12 Server function",
    "text": "1.12 Server function\nNow that you’ve had some practice with the UI, it’s time to move on to the server function.\nAgain, before we get into the details, let’s remind ourselves of the anatomy of a Shiny app. The basic task of the server function is to define the relationship between inputs and outputs.\n\n1.12.1 Here again is the app that we are working with in this module\nEarlier we saw how to build the UI of this app, and we also noted that each input was tagged with an inputId that can be used to refer to them in the server.\n\n\n\n\n\n\n\n\n\n\n\n1.12.2 This is the server function code for this app\nOnce again there is a lot going on here to parse at once, so in the following sections we take a closer look at the function.\n\n\n\n\n\n\n\n\n\n\n\n1.12.3 At the outermost layer\n\n\n\n\n\n\n\n\n\nWe define our server function which takes two arguments: an input and an output. Both of these are named lists.\nThe server function accesses inputs selected by the user to perform computations and specifies how outputs laid out in the UI should be updated.\nThe server function can take on one more argument, session, which is an environment that can be used to access information and functionality relating to the session. However this concept is beyond the scope of this tutorial, so for now we’ll stick to server functions that only have input and output arguments.\n\n\n1.12.4 output\nOur simple app had only one output – a plot. So our server function contains the logic necessary to build this plot.\n\n\n\n\n\n\n\n\n\nThe renderPlot() function specifies how the plot output should be updated. Let’s take a look at what is happening in the renderPlot() function first.\n\n\n1.12.5 renderPlot()\n\n\n\n\n\n\n\n\n\nThis is good ol’ ggplot2 code! So even if you’re new to shiny, if you’ve previously used ggplot2 for plotting in R, this syntax should look familiar to you.\nOne aspect of the syntax that might be new, however, is how the x and y variables are defined. They come from the input list that is built in the UI.\n\n\n1.12.6 Inputs\nHere is the relevant UI and server code.\n\n\n\n\n\n\n\n\n\nInput x and y come from the selectInput() widgets, and map to the x and y arguments of the plot aesthetics.\n\n\n1.12.7 Rules of server functions\nThere are three rules of building server functions:\n\nAlways save objects to display to the named output list, i.e. something of the form output$xx, where xx is the plot you want to display.\nAlways build objects to display with one of the render*() functions, like we built our plot with renderPlot().\nUse input values from the named input list, with input$xx.\n\n\n\n1.12.8 Output types\nJust like various inputs, Shiny also provides a wide selection of output types each of which works with a render function.\n\n\n\n\n\n\n\n\n\nFor example, in our app we used the renderPlot() function to build our reactive plot (we’ll get to what I mean by reactive in a second) and laid out the plot with the plotOutput() function.\n\n\n\n\n\n\n\n\n\nShiny knows to match these two together as they use the same outputID, scatterplot.\nIn the following exercises you’ll get a chance to work with other render/output function pairs to add more elements to your app.\n\n\n1.12.9 Practice: Matching inputs and outputs\nHere is a simple Shiny app. Try entering some text and observe how the text is displayed back to you after a short pause.\n\n\n\n\n\nInput some text here:\n\n\nText is shown below:\n\n\n\n\n#{r, context = \"server\", eval = TRUE} # output$user_text <- renderText({ input$custom_text }) #\n\nThe code for this app is given below, with a few pieces missing (indicated with ___). Each of the blanks are numbered, e.g. ([1], [2], etc.)\n\nlibrary(shiny)\n\nui <- fluidPage(\n\n  textInput(\n    inputId = \"custom_text\",\n    label = \"_[1]_\"\n  ),\n\n  strong(\"Text is shown below:\"),\n\n  _[2]_(outputId = \"_[3]_\")\n\n)\n\nserver <- function(input, output, session){\n\n  output$user_text <- renderText({ input$_[4]_ })\n\n}\n\nshinyApp(ui = ui, server = server)\n\n#{r mc-2} #question(\"Which of the following is false?\", #  answer('`[1]` should be `\"Input some text here:\"`', #         message = \"Take a look at the app, what text is #shown to the user above the text input area?\"), #  answer('`[2]` should be `textOutput`',  #         message = \"Check out the Shiny cheatsheet for pairs #of input and output functions\"), #  answer('`[3]` should be `\"custom_text\"`', correct = TRUE), #  answer('`[4]` should be `\"custom_text\"`', #         message = \"What is the ID of the input that should #be rendered?\"), #  allow_retry = TRUE #) #\n\n\n1.12.10 Reactivity\nLet’s also briefly discuss reactivity.\n\n\n\n\n\n\n\n\n\nIt’s easy to build interactive applications with Shiny, but to get the most out of it, you’ll need to understand the reactive programming scheme used by Shiny.\nIn a nutshell Shiny automatically updates outputs, such as plots, when inputs that go into them change.\n\n\n1.12.11 Putting all the pieces together\nBefore we wrap up this section, I should also mention the last component of each Shiny app, which is a call to the aptly named shinyApp() function, which puts the UI and the server pieces together to create a Shiny app object.\n\n\n\n\n\n\n\n\n\nTime to put this all into practice!\n\n\n1.12.12 Practice: Rules of server functions\nWhich of the following is not true about server functions?\n#{r mc-3} #question(\"Which of the following is not true about server functions?\", #  answer(\"Server functions should include a call to #`runApp()`\", #    correct = TRUE, #    message = \"The `runApp()` function can be used in the Console to run a Shiny application, as an alternative to the Run App button in the RStudio IDE.\" #  ), #  answer(\"Objects to be displayed should be saved to #`output$`\"), #  answer(\"Reactive objects should be built with `render*()` functions\"), #  answer(\"Input values should be referred to with `input$`\"), #  allow_retry = TRUE, #  random_answer_order = TRUE #) #\n\n\n1.12.13 Practice: Fix it up\nBelow is the code for the Shiny app we built earlier, however currently the code is broken. Specifically there are errors in the definition of the server function as well as in the mainPanel of the UI.\n\n1.12.13.1 Your turn\n\nReview the app and identify errors in the code.\n\nHint: Refer back to the rules of server functions.\n\nDo the render functions match the output functions? If not, make the appropriate change and try running the app. Are there any remaining errors?\nAre the inputs referred to using the correct syntax? If not, make the appropriate change and try running the app. Are there any remaining errors?\nAre the outputs referred to using the correct names? If not, make the appropriate change and try running the app. Are there any remaining errors?\n\n\nNavigate to the project called 1-3 Fix it up after clicking the button below\n Go to RStudio Cloud Workspace\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n\n    # Inputs: Select variables to plot\n    sidebarPanel(\n\n      # Select variable for y-axis\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics score\" = \"critics_score\",\n          \"Audience score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      # Select variable for x-axis\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics score\" = \"critics_score\",\n          \"Audience score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      # Select variable for color\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA rating\" = \"mpaa_rating\",\n          \"Critics rating\" = \"critics_rating\",\n          \"Audience rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      )\n    ),\n\n    # Output: Show scatterplot\n    mainPanel(\n      plotOutput(outputId = \"scatterPlot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- renderTable({\n\n    ggplot(data = movies, aes_string(x = x, y = y, color = z)) +\n      geom_point()\n\n  })\n\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "hello.html#recap",
    "href": "hello.html#recap",
    "title": "1  Getting Started",
    "section": "1.13 Recap",
    "text": "1.13 Recap\nLet’s quickly recap what we have learned in this chapter.\n\n1.13.1 \nEvery Shiny app has a webpage that the user visits, and behind this webpage there is a computer that serves this webpage by running R.\n\n\n\n\n\n\n\n\n\n\n\n1.13.2 \nWhen running your app locally, the computer serving your app is your computer.\n\n\n\n\n\n\n\n\n\n\n\n1.13.3 \nWhen your app is deployed, the computer serving your app is a web server.\n\n\n\n\n\n\n\n\n\n\n\n1.13.4 \nEach app is comprised of two components, a UI and a server.\n\n\n\n\n\n\n\n\n\n\nThe UI is ultimately built with HTML, CSS, and JavaScript. However, you as the Shiny developer do not need to know these languages. Shiny lets R users write user interfaces using a simple, familiar-looking API. However there are no limits to customization for advanced users who are familiar with these languages.\nThe server function contains the instructions to map user inputs to outputs.\n\nI often think of the UI as containing syntax specific to Shiny, and the server as containing R code you might already be familiar with – with some Shiny functions added to achieve reactivity.\n\n\n1.13.5 Tip: Change display\nIn this tutorial you will be developing your apps in RStudio Cloud projects, but once you’re done with the tutorial you might consider developing your apps in the RStudio IDE, which has some some handy-dandy functionality for running and viewing your apps.\nRStudio will automatically recognize R scripts that contain ui and server components and that end with a call to the shinyApp() function and will make available the Run App button. You can choose to run your app in a new window, or in the viewer pane of your RStudio window.\n\n\n\n\n\n\n\n\n\n\n\n1.13.6 Tip: Close an app\nWhen you are done with an app, you can terminate the session by clicking the red stop button in your viewer pane.\n\n\n\n\n\n\n\n\n\n\n\n1.13.7 \nThat’s all for this module! In the next module we discuss inputs, outputs, and rendering functions in further detail."
  },
  {
    "objectID": "hello.html#welcome",
    "href": "hello.html#welcome",
    "title": "1  Hello Shiny",
    "section": "1.1 Welcome",
    "text": "1.1 Welcome\n\n1.1.1 \nThis tutorial comprised of four modules will introduce you to Shiny, the R package for building interactive web apps straight from R.\nIn this module, we’ll begin by introducing the basics of Shiny.\nSo, let’s get to it…\n\n\n1.1.2 Here is a Shiny app\nAnd not just any app, an app that you will be able to build by the end of this tutorial!\n\n\n\n\n\nhttps://minecr.shinyapps.io/movies/?showcase=0\n\n\n1200px\n\n\nhttps://minecr.shinyapps.io/movies/\n\n\n\n\n1.1.3 \nWe’ll go through the technical details of each component of such an app throughout the tutorial, but for now let’s take a high level view.\n\n\n\n\n\n\n\n\n\nWe have:\n\na title for the app,\na series of inputs:\n\nsome of these inputs use drop down menus for selection,\nsome are sliders,\nsome allow for text input, and\nsome are action buttons\n\nand a few outputs:\n\na plot output that the user can interactively update,\na text output that updates alongside it, and\na data table output that also updates alongside these.\n\n\nAs much as it looks like there is a lot going on in this sample app, the app doesn’t even scratch the surface of what you can build with Shiny.\nI hope you’re excited to take it all in!\n\n\n1.1.4 Background\nBefore we get started with Shiny, let’s talk background…\nThis tutorial assumes that you are familiar with R as a programming language.\nAdditionally, this tutorial uses packages from the tidyverse (e.g. dplyr for data wrangling and ggplot2 for data visualisation). Your Shiny apps can use any package, but if you’d like to learn more about doing data science with the tidyverse, see here.\n\n\n1.1.5 Help\nThe tutorial is designed for beginners and many of the exercises have plenty of scaffolding to help you along the way.\nThat being said, there are a few other resources that might help your learning.\n\n\n\n\n\n\n\n\n\n\nThe first is the Shiny cheatsheet. This is a handy-dandy cheatsheet that I recommend you keep close by when building Shiny apps.\nThe second is the Shiny homepage. It is the place to learn about all things Shiny and to keep up to date with it as it evolves.\n\n\n\n1.1.6 Tips\nAlso, let’s go over three very important tips for learning to develop Shiny apps:\n\nAlways run the entire script containing the R code, not just up to the point where you’re developing code. For most exercises in this tutorial you will be asked to modify or update existing Shiny code, and even though you might be altering a small portion of the code, you still need to run the entire app code to create the app.\nSometimes the best way to troubleshoot is to run the app and review the error. Not only can the error message be informative, but googling the error message might quickly land you on a solution.\nWatch out for commas! This will mean more as you start to learn Shiny, but just keep in mind, a Shiny error can often be caused by a missing comma. Thankfully, the RStudio IDE will alert you to most of these missing comma or similar syntax errors, like the one shown below.\n\n\n\n\n\n\n\n\n\n\n\n\n1.1.7 Anatomy of a Shiny app\nAlrighty, let’s take a look at the anatomy of a Shiny app:\n\n\n\n\n\n\n\n\n\n\nWe start by loading any necessary packages, one of which is necessarily shiny.\nThen we lay out the user interface with a ui object that controls the appearance of our app.\nAnd we define the server function that contains instructions needed to build the app.\nWe end each Shiny app script with a call to the shinyApp() function that puts these two components together to create the Shiny app object.\n\n\n\n1.1.8 Data\nIn this tutorial we will build a simple movie browser app.\nWe will use data from the movies dataset, which combines data from two websites: the Internet Movie Database, commonly known as IMDB, and Rotten Tomatoes. The observations are a random sample of 651 movies released in the US between 1970 and 2014.\nSo where does the loading of the data happen in an app?\n\n\n1.1.9 Revisit\nLet’s revisit the app layout from a couple sections back.\n\n\n\n\n\n\n\n\n\nWe load the data before ui and server definitions so that it can be used in both.\nAlright, time for some practice!\n\n\n1.1.10 Practice: What’s in an app?\nWhich of these is not generally a part of the Shiny app architecture?” - A function that installs an R package - User interface - Server function - A function that creates Shiny app objects\nAnswer: A function that installs an R package. You don’t want to reinstall the package every time you run your app, so you should do this once in your console instead of within your Shiny app\n\n\n1.1.11 Practice: First peek under the hood\nBelow you can see the complete code to reproduce the app we introduced in the previous section. Now you get to interact with the app yourself, and make small adjustments to it.\nI’ve created an RStudio Cloud Project for you to test drive this code. Click the button below to be taken to your RStudio Workspace, select 1.1 First peek under the hood from the Project list, and follow the exercise instructions below to get started!\n\nNavigate to the project called 1-1 First peek under the hood after clicking the button below\n Go to RStudio Cloud Workspace\n\n\n1.1.11.1 Your turn\n\nOnce your RStudio Cloud Project is open to the script app.R, click  to run the code and generate the app.\nPlay with the input selectors for the Y-axis and the X-axis and observe how the output changes.\nClose the app by closing the pop-up window or clicking on the red Stop button in the viewer.\nLocate the relevant lines of code in app.R that build the selector widget for the Y-axis. This is in a selectInput() function starting on Line 20, underneath the comment # Select variable for y-axis. Note that this function takes four arguments: inputId, label, choices, and selected. We’ll discuss what each of these mean in detail shortly. For now, change the selected argument to imdb_rating, save your changes, and run the app again by clicking on . What changed?\n\nIf you get an error when you try to rerun the app, you can either try to debug the issue by tracing back your steps or delete everything in app.R and copy and paste the code below into app.R. This will get you back to your starting point. You can use this “start over” approach for any of the exercises in this tutorial.\n\nNow locate the relevant lines of code in app.R that build the selector widget for the X-axis. This is also in a selectInput() function, starting on Line 27, underneath the comment # Select variable for x-axis. Change the selected argument to imdb_rating as well, save your changes, and run the app again. What changed?\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n\n  sidebarLayout(\n\n    # Inputs: Select variables to plot\n    sidebarPanel(\n\n      # Select variable for y-axis\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"audience_score\"\n      ),\n      # Select variable for x-axis\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"critics_score\"\n      )\n    ),\n\n    # Output: Show scatterplot\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "hello.html#background",
    "href": "hello.html#background",
    "title": "1  Getting Started",
    "section": "1.2 Background",
    "text": "1.2 Background\nBefore we get started with Shiny, let’s talk background…\nThis tutorial assumes that you are familiar with R as a programming language.\nAdditionally, this tutorial uses packages from the tidyverse (e.g. dplyr for data wrangling and ggplot2 for data visualisation). Your Shiny apps can use any package, but if you’d like to learn more about doing data science with the tidyverse, see here."
  },
  {
    "objectID": "hello.html#help",
    "href": "hello.html#help",
    "title": "1  Getting Started",
    "section": "1.3 Help",
    "text": "1.3 Help\nThe tutorial is designed for beginners and many of the exercises have plenty of scaffolding to help you along the way.\nThat being said, there are a few other resources that might help your learning.\n\n\n\n\n\n\n\n\n\n\nThe first is the Shiny cheatsheet. This is a handy-dandy cheatsheet that I recommend you keep close by when building Shiny apps.\nThe second is the Shiny homepage. It is the place to learn about all things Shiny and to keep up to date with it as it evolves."
  },
  {
    "objectID": "hello.html#tips",
    "href": "hello.html#tips",
    "title": "1  Getting Started",
    "section": "1.4 Tips",
    "text": "1.4 Tips\nAlso, let’s go over three very important tips for learning to develop Shiny apps:\n\nAlways run the entire script containing the R code, not just up to the point where you’re developing code. For most exercises in this tutorial you will be asked to modify or update existing Shiny code, and even though you might be altering a small portion of the code, you still need to run the entire app code to create the app.\nSometimes the best way to troubleshoot is to run the app and review the error. Not only can the error message be informative, but googling the error message might quickly land you on a solution.\nWatch out for commas! This will mean more as you start to learn Shiny, but just keep in mind, a Shiny error can often be caused by a missing comma. Thankfully, the RStudio IDE will alert you to most of these missing comma or similar syntax errors, like the one shown below."
  },
  {
    "objectID": "hello.html#anatomy-of-a-shiny-app",
    "href": "hello.html#anatomy-of-a-shiny-app",
    "title": "1  Getting Started",
    "section": "1.5 Anatomy of a Shiny app",
    "text": "1.5 Anatomy of a Shiny app\nAlrighty, let’s take a look at the anatomy of a Shiny app:\n\n\n\n\n\n\n\n\n\n\nWe start by loading any necessary packages, one of which is necessarily shiny.\nThen we lay out the user interface with a ui object that controls the appearance of our app.\nAnd we define the server function that contains instructions needed to build the app.\nWe end each Shiny app script with a call to the shinyApp() function that puts these two components together to create the Shiny app object."
  },
  {
    "objectID": "hello.html#data",
    "href": "hello.html#data",
    "title": "1  Getting Started",
    "section": "1.6 Data",
    "text": "1.6 Data\nIn this tutorial we will build a simple movie browser app.\nWe will use data from the movies dataset, which combines data from two websites: the Internet Movie Database, commonly known as IMDB, and Rotten Tomatoes. The observations are a random sample of 651 movies released in the US between 1970 and 2014.\nSo where does the loading of the data happen in an app?"
  },
  {
    "objectID": "hello.html#revisit",
    "href": "hello.html#revisit",
    "title": "1  Getting Started",
    "section": "1.7 Revisit",
    "text": "1.7 Revisit\nLet’s revisit the app layout from a couple sections back.\n\n\n\n\n\n\n\n\n\nWe load the data before ui and server definitions so that it can be used in both.\nAlright, time for some practice!"
  },
  {
    "objectID": "hello.html#practice-whats-in-an-app",
    "href": "hello.html#practice-whats-in-an-app",
    "title": "1  Getting Started",
    "section": "1.8 Practice: What’s in an app?",
    "text": "1.8 Practice: What’s in an app?\nWhich of these is not generally a part of the Shiny app architecture?” - A function that installs an R package - User interface - Server function - A function that creates Shiny app objects\nAnswer: A function that installs an R package. You don’t want to reinstall the package every time you run your app, so you should do this once in your console instead of within your Shiny app"
  },
  {
    "objectID": "hello.html#practice-first-peek-under-the-hood",
    "href": "hello.html#practice-first-peek-under-the-hood",
    "title": "1  Getting Started",
    "section": "1.9 Practice: First peek under the hood",
    "text": "1.9 Practice: First peek under the hood\nBelow you can see the complete code to reproduce the app we introduced in the previous section. Now you get to interact with the app yourself, and make small adjustments to it.\nI’ve created an RStudio Cloud Project for you to test drive this code. Click the button below to be taken to your RStudio Workspace, select 1.1 First peek under the hood from the Project list, and follow the exercise instructions below to get started!\n\nNavigate to the project called 1-1 First peek under the hood after clicking the button below\n Go to RStudio Cloud Workspace"
  },
  {
    "objectID": "hello.html#your-turn",
    "href": "hello.html#your-turn",
    "title": "1  Getting Started",
    "section": "1.10 Your turn",
    "text": "1.10 Your turn\n\nOnce your RStudio Cloud Project is open to the script app.R, click  to run the code and generate the app.\nPlay with the input selectors for the Y-axis and the X-axis and observe how the output changes.\nClose the app by closing the pop-up window or clicking on the red Stop button in the viewer.\nLocate the relevant lines of code in app.R that build the selector widget for the Y-axis. This is in a selectInput() function starting on Line 20, underneath the comment # Select variable for y-axis. Note that this function takes four arguments: inputId, label, choices, and selected. We’ll discuss what each of these mean in detail shortly. For now, change the selected argument to imdb_rating, save your changes, and run the app again by clicking on . What changed?\n\nIf you get an error when you try to rerun the app, you can either try to debug the issue by tracing back your steps or delete everything in app.R and copy and paste the code below into app.R. This will get you back to your starting point. You can use this “start over” approach for any of the exercises in this tutorial.\n\nNow locate the relevant lines of code in app.R that build the selector widget for the X-axis. This is also in a selectInput() function, starting on Line 27, underneath the comment # Select variable for x-axis. Change the selected argument to imdb_rating as well, save your changes, and run the app again. What changed?\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n\n  sidebarLayout(\n\n    # Inputs: Select variables to plot\n    sidebarPanel(\n\n      # Select variable for y-axis\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"audience_score\"\n      ),\n      # Select variable for x-axis\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"critics_score\"\n      )\n    ),\n\n    # Output: Show scatterplot\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "hello-server.html",
    "href": "hello-server.html",
    "title": "3  Server function",
    "section": "",
    "text": "Now that you’ve had some practice with the UI, it’s time to move on to the server function.\nAgain, before we get into the details, let’s remind ourselves of the anatomy of a Shiny app. The basic task of the server function is to define the relationship between inputs and outputs."
  },
  {
    "objectID": "hello-server.html#recap",
    "href": "hello-server.html#recap",
    "title": "3  Server function",
    "section": "3.1 Recap",
    "text": "3.1 Recap\nLet’s quickly recap what we have learned in this chapter.\n\n3.1.1 \nEvery Shiny app has a webpage that the user visits, and behind this webpage there is a computer that serves this webpage by running R.\n\n\n\n\n\n\n\n\n\n\n\n3.1.2 \nWhen running your app locally, the computer serving your app is your computer.\n\n\n\n\n\n\n\n\n\n\n\n3.1.3 \nWhen your app is deployed, the computer serving your app is a web server.\n\n\n\n\n\n\n\n\n\n\n\n3.1.4 \nEach app is comprised of two components, a UI and a server.\n\n\n\n\n\n\n\n\n\n\nThe UI is ultimately built with HTML, CSS, and JavaScript. However, you as the Shiny developer do not need to know these languages. Shiny lets R users write user interfaces using a simple, familiar-looking API. However there are no limits to customization for advanced users who are familiar with these languages.\nThe server function contains the instructions to map user inputs to outputs.\n\nI often think of the UI as containing syntax specific to Shiny, and the server as containing R code you might already be familiar with – with some Shiny functions added to achieve reactivity.\n\n\n3.1.5 Tip: Change display\nIn this tutorial you will be developing your apps in RStudio Cloud projects, but once you’re done with the tutorial you might consider developing your apps in the RStudio IDE, which has some some handy-dandy functionality for running and viewing your apps.\nRStudio will automatically recognize R scripts that contain ui and server components and that end with a call to the shinyApp() function and will make available the Run App button. You can choose to run your app in a new window, or in the viewer pane of your RStudio window.\n\n\n\n\n\n\n\n\n\n\n\n3.1.6 Tip: Close an app\nWhen you are done with an app, you can terminate the session by clicking the red stop button in your viewer pane.\n\n\n\n\n\n\n\n\n\n\n\n3.1.7 \nThat’s all for this module! In the next module we discuss inputs, outputs, and rendering functions in further detail."
  },
  {
    "objectID": "hello-recap.html",
    "href": "hello-recap.html",
    "title": "4  Recap",
    "section": "",
    "text": "4.0.1 \nEvery Shiny app has a webpage that the user visits, and behind this webpage there is a computer that serves this webpage by running R.\n\n\n\n\n\n\n\n\n\n\n\n4.0.2 \nWhen running your app locally, the computer serving your app is your computer.\n\n\n\n\n\n\n\n\n\n\n\n4.0.3 \nWhen your app is deployed, the computer serving your app is a web server.\n\n\n\n\n\n\n\n\n\n\n\n4.0.4 \nEach app is comprised of two components, a UI and a server.\n\n\n\n\n\n\n\n\n\n\nThe UI is ultimately built with HTML, CSS, and JavaScript. However, you as the Shiny developer do not need to know these languages. Shiny lets R users write user interfaces using a simple, familiar-looking API. However there are no limits to customization for advanced users who are familiar with these languages.\nThe server function contains the instructions to map user inputs to outputs.\n\nI often think of the UI as containing syntax specific to Shiny, and the server as containing R code you might already be familiar with – with some Shiny functions added to achieve reactivity.\n\n\n4.0.5 Tip: Change display\nIn this tutorial you will be developing your apps in RStudio Cloud projects, but once you’re done with the tutorial you might consider developing your apps in the RStudio IDE, which has some some handy-dandy functionality for running and viewing your apps.\nRStudio will automatically recognize R scripts that contain ui and server components and that end with a call to the shinyApp() function and will make available the Run App button. You can choose to run your app in a new window, or in the viewer pane of your RStudio window.\n\n\n\n\n\n\n\n\n\n\n\n4.0.6 Tip: Close an app\nWhen you are done with an app, you can terminate the session by clicking the red stop button in your viewer pane.\n\n\n\n\n\n\n\n\n\n\n\n4.0.7 \nThat’s all for this module! In the next module we discuss inputs, outputs, and rendering functions in further detail."
  },
  {
    "objectID": "hello-ui.html",
    "href": "hello-ui.html",
    "title": "2  User interface (UI)",
    "section": "",
    "text": "In this section we’ll build the user interface of a simple app.\nHowever, before we get into the weeds of building a user interface, let’s revisit the anatomy of a Shiny app."
  },
  {
    "objectID": "hello-ui.html#server-function",
    "href": "hello-ui.html#server-function",
    "title": "2  User interface (UI)",
    "section": "2.1 Server function",
    "text": "2.1 Server function\nNow that you’ve had some practice with the UI, it’s time to move on to the server function.\nAgain, before we get into the details, let’s remind ourselves of the anatomy of a Shiny app. The basic task of the server function is to define the relationship between inputs and outputs.\n\n2.1.1 Here again is the app that we are working with in this module\nEarlier we saw how to build the UI of this app, and we also noted that each input was tagged with an inputId that can be used to refer to them in the server.\n\n\n\n\n\n\n\n\n\n\n\n2.1.2 This is the server function code for this app\nOnce again there is a lot going on here to parse at once, so in the following sections we take a closer look at the function.\n\n\n\n\n\n\n\n\n\n\n\n2.1.3 At the outermost layer\n\n\n\n\n\n\n\n\n\nWe define our server function which takes two arguments: an input and an output. Both of these are named lists.\nThe server function accesses inputs selected by the user to perform computations and specifies how outputs laid out in the UI should be updated.\nThe server function can take on one more argument, session, which is an environment that can be used to access information and functionality relating to the session. However this concept is beyond the scope of this tutorial, so for now we’ll stick to server functions that only have input and output arguments.\n\n\n2.1.4 output\nOur simple app had only one output – a plot. So our server function contains the logic necessary to build this plot.\n\n\n\n\n\n\n\n\n\nThe renderPlot() function specifies how the plot output should be updated. Let’s take a look at what is happening in the renderPlot() function first.\n\n\n2.1.5 renderPlot()\n\n\n\n\n\n\n\n\n\nThis is good ol’ ggplot2 code! So even if you’re new to shiny, if you’ve previously used ggplot2 for plotting in R, this syntax should look familiar to you.\nOne aspect of the syntax that might be new, however, is how the x and y variables are defined. They come from the input list that is built in the UI.\n\n\n2.1.6 Inputs\nHere is the relevant UI and server code.\n\n\n\n\n\n\n\n\n\nInput x and y come from the selectInput() widgets, and map to the x and y arguments of the plot aesthetics.\n\n\n2.1.7 Rules of server functions\nThere are three rules of building server functions:\n\nAlways save objects to display to the named output list, i.e. something of the form output$xx, where xx is the plot you want to display.\nAlways build objects to display with one of the render*() functions, like we built our plot with renderPlot().\nUse input values from the named input list, with input$xx.\n\n\n\n2.1.8 Output types\nJust like various inputs, Shiny also provides a wide selection of output types each of which works with a render function.\n\n\n\n\n\n\n\n\n\nFor example, in our app we used the renderPlot() function to build our reactive plot (we’ll get to what I mean by reactive in a second) and laid out the plot with the plotOutput() function.\n\n\n\n\n\n\n\n\n\nShiny knows to match these two together as they use the same outputID, scatterplot.\nIn the following exercises you’ll get a chance to work with other render/output function pairs to add more elements to your app.\n\n\n2.1.9 Practice: Matching inputs and outputs\nHere is a simple Shiny app. Try entering some text and observe how the text is displayed back to you after a short pause.\n\n\n\n\n\nInput some text here:\n\n\nText is shown below:\n\n\n\n\n#{r, context = \"server\", eval = TRUE} # output$user_text <- renderText({ input$custom_text }) #\n\nThe code for this app is given below, with a few pieces missing (indicated with ___). Each of the blanks are numbered, e.g. ([1], [2], etc.)\n\nlibrary(shiny)\n\nui <- fluidPage(\n\n  textInput(\n    inputId = \"custom_text\",\n    label = \"_[1]_\"\n  ),\n\n  strong(\"Text is shown below:\"),\n\n  _[2]_(outputId = \"_[3]_\")\n\n)\n\nserver <- function(input, output, session){\n\n  output$user_text <- renderText({ input$_[4]_ })\n\n}\n\nshinyApp(ui = ui, server = server)\n\n#{r mc-2} #question(\"Which of the following is false?\", #  answer('`[1]` should be `\"Input some text here:\"`', #         message = \"Take a look at the app, what text is #shown to the user above the text input area?\"), #  answer('`[2]` should be `textOutput`',  #         message = \"Check out the Shiny cheatsheet for pairs #of input and output functions\"), #  answer('`[3]` should be `\"custom_text\"`', correct = TRUE), #  answer('`[4]` should be `\"custom_text\"`', #         message = \"What is the ID of the input that should #be rendered?\"), #  allow_retry = TRUE #) #\n\n\n2.1.10 Reactivity\nLet’s also briefly discuss reactivity.\n\n\n\n\n\n\n\n\n\nIt’s easy to build interactive applications with Shiny, but to get the most out of it, you’ll need to understand the reactive programming scheme used by Shiny.\nIn a nutshell Shiny automatically updates outputs, such as plots, when inputs that go into them change.\n\n\n2.1.11 Putting all the pieces together\nBefore we wrap up this section, I should also mention the last component of each Shiny app, which is a call to the aptly named shinyApp() function, which puts the UI and the server pieces together to create a Shiny app object.\n\n\n\n\n\n\n\n\n\nTime to put this all into practice!\n\n\n2.1.12 Practice: Rules of server functions\nWhich of the following is not true about server functions?\n#{r mc-3} #question(\"Which of the following is not true about server functions?\", #  answer(\"Server functions should include a call to #`runApp()`\", #    correct = TRUE, #    message = \"The `runApp()` function can be used in the Console to run a Shiny application, as an alternative to the Run App button in the RStudio IDE.\" #  ), #  answer(\"Objects to be displayed should be saved to #`output$`\"), #  answer(\"Reactive objects should be built with `render*()` functions\"), #  answer(\"Input values should be referred to with `input$`\"), #  allow_retry = TRUE, #  random_answer_order = TRUE #) #\n\n\n2.1.13 Practice: Fix it up\nBelow is the code for the Shiny app we built earlier, however currently the code is broken. Specifically there are errors in the definition of the server function as well as in the mainPanel of the UI.\n\n2.1.13.1 Your turn\n\nReview the app and identify errors in the code.\n\nHint: Refer back to the rules of server functions.\n\nDo the render functions match the output functions? If not, make the appropriate change and try running the app. Are there any remaining errors?\nAre the inputs referred to using the correct syntax? If not, make the appropriate change and try running the app. Are there any remaining errors?\nAre the outputs referred to using the correct names? If not, make the appropriate change and try running the app. Are there any remaining errors?\n\n\nNavigate to the project called 1-3 Fix it up after clicking the button below\n Go to RStudio Cloud Workspace\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n\n    # Inputs: Select variables to plot\n    sidebarPanel(\n\n      # Select variable for y-axis\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics score\" = \"critics_score\",\n          \"Audience score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      # Select variable for x-axis\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics score\" = \"critics_score\",\n          \"Audience score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      # Select variable for color\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA rating\" = \"mpaa_rating\",\n          \"Critics rating\" = \"critics_rating\",\n          \"Audience rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      )\n    ),\n\n    # Output: Show scatterplot\n    mainPanel(\n      plotOutput(outputId = \"scatterPlot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- renderTable({\n\n    ggplot(data = movies, aes_string(x = x, y = y, color = z)) +\n      geom_point()\n\n  })\n\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "hello-ui.html#recap",
    "href": "hello-ui.html#recap",
    "title": "2  User interface (UI)",
    "section": "2.2 Recap",
    "text": "2.2 Recap\nLet’s quickly recap what we have learned in this chapter.\n\n2.2.1 \nEvery Shiny app has a webpage that the user visits, and behind this webpage there is a computer that serves this webpage by running R.\n\n\n\n\n\n\n\n\n\n\n\n2.2.2 \nWhen running your app locally, the computer serving your app is your computer.\n\n\n\n\n\n\n\n\n\n\n\n2.2.3 \nWhen your app is deployed, the computer serving your app is a web server.\n\n\n\n\n\n\n\n\n\n\n\n2.2.4 \nEach app is comprised of two components, a UI and a server.\n\n\n\n\n\n\n\n\n\n\nThe UI is ultimately built with HTML, CSS, and JavaScript. However, you as the Shiny developer do not need to know these languages. Shiny lets R users write user interfaces using a simple, familiar-looking API. However there are no limits to customization for advanced users who are familiar with these languages.\nThe server function contains the instructions to map user inputs to outputs.\n\nI often think of the UI as containing syntax specific to Shiny, and the server as containing R code you might already be familiar with – with some Shiny functions added to achieve reactivity.\n\n\n2.2.5 Tip: Change display\nIn this tutorial you will be developing your apps in RStudio Cloud projects, but once you’re done with the tutorial you might consider developing your apps in the RStudio IDE, which has some some handy-dandy functionality for running and viewing your apps.\nRStudio will automatically recognize R scripts that contain ui and server components and that end with a call to the shinyApp() function and will make available the Run App button. You can choose to run your app in a new window, or in the viewer pane of your RStudio window.\n\n\n\n\n\n\n\n\n\n\n\n2.2.6 Tip: Close an app\nWhen you are done with an app, you can terminate the session by clicking the red stop button in your viewer pane.\n\n\n\n\n\n\n\n\n\n\n\n2.2.7 \nThat’s all for this module! In the next module we discuss inputs, outputs, and rendering functions in further detail."
  }
]