[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "shinygs",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "hello.html#welcome",
    "href": "hello.html#welcome",
    "title": "2  Hello Shiny",
    "section": "2.1 Welcome",
    "text": "2.1 Welcome\n\n2.1.1 \nThis tutorial comprised of four modules will introduce you to Shiny, the R package for building interactive web apps straight from R.\nIn this module, we’ll begin by introducing the basics of Shiny.\nSo, let’s get to it…\n\n\n2.1.2 Here is a Shiny app\nAnd not just any app, an app that you will be able to build by the end of this tutorial!\n\n\n\n\n\nhttps://minecr.shinyapps.io/movies/?showcase=0\n\n\n1200px\n\n\nhttps://minecr.shinyapps.io/movies/\n\n\n\n\n2.1.3 \nWe’ll go through the technical details of each component of such an app throughout the tutorial, but for now let’s take a high level view.\n\n\n\n\n\n\n\n\n\nWe have:\n\na title for the app,\na series of inputs:\n\nsome of these inputs use drop down menus for selection,\nsome are sliders,\nsome allow for text input, and\nsome are action buttons\n\nand a few outputs:\n\na plot output that the user can interactively update,\na text output that updates alongside it, and\na data table output that also updates alongside these.\n\n\nAs much as it looks like there is a lot going on in this sample app, the app doesn’t even scratch the surface of what you can build with Shiny.\nI hope you’re excited to take it all in!\n\n\n2.1.4 Background\nBefore we get started with Shiny, let’s talk background…\nThis tutorial assumes that you are familiar with R as a programming language.\nAdditionally, this tutorial uses packages from the tidyverse (e.g. dplyr for data wrangling and ggplot2 for data visualisation). Your Shiny apps can use any package, but if you’d like to learn more about doing data science with the tidyverse, see here.\n\n\n2.1.5 Help\nThe tutorial is designed for beginners and many of the exercises have plenty of scaffolding to help you along the way.\nThat being said, there are a few other resources that might help your learning.\n\n\n\n\n\n\n\n\n\n\nThe first is the Shiny cheatsheet. This is a handy-dandy cheatsheet that I recommend you keep close by when building Shiny apps.\nThe second is the Shiny homepage. It is the place to learn about all things Shiny and to keep up to date with it as it evolves.\n\n\n\n2.1.6 Tips\nAlso, let’s go over three very important tips for learning to develop Shiny apps:\n\nAlways run the entire script containing the R code, not just up to the point where you’re developing code. For most exercises in this tutorial you will be asked to modify or update existing Shiny code, and even though you might be altering a small portion of the code, you still need to run the entire app code to create the app.\nSometimes the best way to troubleshoot is to run the app and review the error. Not only can the error message be informative, but googling the error message might quickly land you on a solution.\nWatch out for commas! This will mean more as you start to learn Shiny, but just keep in mind, a Shiny error can often be caused by a missing comma. Thankfully, the RStudio IDE will alert you to most of these missing comma or similar syntax errors, like the one shown below.\n\n\n\n\n\n\n\n\n\n\n\n\n2.1.7 Anatomy of a Shiny app\nAlrighty, let’s take a look at the anatomy of a Shiny app:\n\n\n\n\n\n\n\n\n\n\nWe start by loading any necessary packages, one of which is necessarily shiny.\nThen we lay out the user interface with a ui object that controls the appearance of our app.\nAnd we define the server function that contains instructions needed to build the app.\nWe end each Shiny app script with a call to the shinyApp() function that puts these two components together to create the Shiny app object.\n\n\n\n2.1.8 Data\nIn this tutorial we will build a simple movie browser app.\nWe will use data from the movies dataset, which combines data from two websites: the Internet Movie Database, commonly known as IMDB, and Rotten Tomatoes. The observations are a random sample of 651 movies released in the US between 1970 and 2014.\nSo where does the loading of the data happen in an app?\n\n\n2.1.9 Revisit\nLet’s revisit the app layout from a couple sections back.\n\n\n\n\n\n\n\n\n\nWe load the data before ui and server definitions so that it can be used in both.\nAlright, time for some practice!\n\n\n2.1.10 Practice: What’s in an app?\nWhich of these is not generally a part of the Shiny app architecture?” - A function that installs an R package - User interface - Server function - A function that creates Shiny app objects\nAnswer: A function that installs an R package. You don’t want to reinstall the package every time you run your app, so you should do this once in your console instead of within your Shiny app\n\n\n2.1.11 Practice: First peek under the hood\nBelow you can see the complete code to reproduce the app we introduced in the previous section. Now you get to interact with the app yourself, and make small adjustments to it.\nI’ve created an RStudio Cloud Project for you to test drive this code. Click the button below to be taken to your RStudio Workspace, select 1.1 First peek under the hood from the Project list, and follow the exercise instructions below to get started!\n\nNavigate to the project called 1-1 First peek under the hood after clicking the button below\n Go to RStudio Cloud Workspace\n\n\n2.1.11.1 Your turn\n\nOnce your RStudio Cloud Project is open to the script app.R, click  to run the code and generate the app.\nPlay with the input selectors for the Y-axis and the X-axis and observe how the output changes.\nClose the app by closing the pop-up window or clicking on the red Stop button in the viewer.\nLocate the relevant lines of code in app.R that build the selector widget for the Y-axis. This is in a selectInput() function starting on Line 20, underneath the comment # Select variable for y-axis. Note that this function takes four arguments: inputId, label, choices, and selected. We’ll discuss what each of these mean in detail shortly. For now, change the selected argument to imdb_rating, save your changes, and run the app again by clicking on . What changed?\n\nIf you get an error when you try to rerun the app, you can either try to debug the issue by tracing back your steps or delete everything in app.R and copy and paste the code below into app.R. This will get you back to your starting point. You can use this “start over” approach for any of the exercises in this tutorial.\n\nNow locate the relevant lines of code in app.R that build the selector widget for the X-axis. This is also in a selectInput() function, starting on Line 27, underneath the comment # Select variable for x-axis. Change the selected argument to imdb_rating as well, save your changes, and run the app again. What changed?\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n\n  sidebarLayout(\n\n    # Inputs: Select variables to plot\n    sidebarPanel(\n\n      # Select variable for y-axis\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"audience_score\"\n      ),\n      # Select variable for x-axis\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"critics_score\"\n      )\n    ),\n\n    # Output: Show scatterplot\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "hello.html#user-interface-ui",
    "href": "hello.html#user-interface-ui",
    "title": "2  Hello Shiny",
    "section": "2.2 User interface (UI)",
    "text": "2.2 User interface (UI)\n\n2.2.1 \nIn this section we’ll build the user interface of a simple app.\nHowever, before we get into the weeds of building a user interface, let’s revisit the anatomy of a Shiny app.\n\n\n\n\n\n\n\n\n\n\nThe user interface, that we’ll refer to as the “UI” going forward, defines and lays out the inputs of your app where users can make their selections. It also lays out the outputs.\nThe server function, on the other hand, calculates outputs and performs any other calculations needed for the outputs.\n\n\n\n2.2.2 Example\n\n\n\n\n\n\n\n\n\nFor example, if your app features a plot the code for building that plot lives in the server function. But the setup for the user defined inputs for the plot, as well as information on where physically on the app the plot should appear, are defined in the UI.\n\n\n2.2.3 \nHere is the app we’ll work with in this section and the code that builds the UI of that app.\nSince this is too much code to parse, we’ll explore individual components of the UI one by one.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.2.4 fluidPage()\nAt the outermost layer of our UI definition we begin with the fluidPage() function.\n\n\n\n\n\n\n\n\n\nThe fluidPage() function creates a fluid page layout consisting of rows and columns. Rows make sure that elements in them appear on the same line. Columns within these rows define how much horizontal space each element should occupy.\nFluid pages scale their components in realtime to fill all available browser width, which means you, the app developer, don’t need to worry about defining relative widths for individual app components.\nAs always, for more information on arguments to this function, you can view the R function help by typing ?fluidPage in your R console or visiting the function reference page on the package website here.\n\n\n2.2.5 Layout\nNext, we define the layout of our app with sidebarLayout().\n\n\n\n\n\n\n\n\n\nShiny includes a number of options for laying out the components of an application. The default layout, the one we’re using in our example app, is a layout with a sidebar, that you can define with the sidebarLayout() function.\n\n\n\n\n\n\n\n\n\nThis is a simple layout with a narrow sidebar for inputs and a wider main area for output.\nUnder the hood, Shiny implements layout features available in Bootstrap 2, which is a popular HTML/CSS framework. However the nice thing about working in Shiny is that no prior experience with Bootstrap is necessary.\nTo learn more about various layouts, I recommend reviewing the Application Layout Guide article at shiny.rstudio.com.\n\n\n2.2.6 Input controls\nNext we define our sidebar panel containing input controls.\n\n\n\n\n\n\n\n\n\n\n\n2.2.7 \nThis panel contains two dropdown menus created with the selectInput() function.\n\n\n\n\n\n\n\n\n\n\n\n2.2.8 \nLet’s take a look at one of the selectInput widgets a little more closely.\n\n\n\n\n\n\n\n\n\n\nThe first argument is the inputId, which is the input value that the app will internally use to access the value selected by the user.\nThe second argument is the label, which is the display label that the user sees.\nThe third argument is the list of choices the user will choose from. In this app, these are variable names from the movies dataset.\nAnd lastly we specify a default selection from that list with selected.\n\n\n\n2.2.9 Main Panel\nThe final component of our UI is mainPanel().\n\n\n\n\n\n\n\n\n\nCurrently the main panel contains only one component, a plot output. We’ll talk about how this plot is built later in the tutorial.\nNext, let’s practice building an app UI!\n\n\n2.2.10 Practice: Extend the UI\nWe’ll start with a simplified version of the app you saw in the previous exercise. In this app a selectInput() widget is used to allow the user to select which variables should be plotted on the x and y axes of the scatterplot.\nThe selectInput() function has the following arguments:\n\nan inputId that is used to refer to the input parameter when building the scatterplot,\na list of choices to pick from (which must match variable names in the data frame),\nand a selected choice for when the app first launches.\n\n\n2.2.10.1 Your turn\nModify the Shiny app code in app.R / shown below:\n\nIn the ui:\n\nAdd a new selectInput widget to color the points by a choice of the following variables: \"title_type\", \"genre\", \"mpaa_rating\", \"critics_rating\", \"audience_rating\".\nMake the default selection \"mpaa_rating\".\nUse \"z\" as the inputId.\nlabel can be whatever you like.\n\nIn the server:\n\nSet the color argument in ggplot() aesthetic mappings to input$z.\n\n\n\nComplete this exercise by opening up the RStudio Project titled 1-2a Extend the UI within your RStudio Cloud Workspace\n Go to RStudio Cloud Workspace\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  \n  sidebarLayout(\n    \n    # Inputs: Select variables to plot\n    sidebarPanel(\n      \n      # Select variable for y-axis\n      selectInput(inputId = \"y\", \n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"), \n                  selected = \"audience_score\"),\n      \n      # Select variable for x-axis\n      selectInput(inputId = \"x\", \n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"), \n                  selected = \"critics_score\"),\n      \n      # Select variable for color\n      selectInput(inputId = \"___\", \n                  label = \"____\",\n                  choices = c(___),\n                  selected = \"___\")\n      \n    ),\n    \n    # Output: Show scatterplot\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y,\n                                     color = ___)) +\n      geom_point()\n  })\n  \n  }\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  \n  sidebarLayout(\n    \n    # Inputs: Select variables to plot\n    sidebarPanel(\n      \n      # Select variable for y-axis\n      selectInput(inputId = \"y\", \n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"), \n                  selected = \"audience_score\"),\n      \n      # Select variable for x-axis\n      selectInput(inputId = \"x\", \n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"), \n                  selected = \"critics_score\"),\n      \n      # Select variable for color\n      selectInput(inputId = \"z\", \n                  label = \"Color by:\",\n                  choices = c(\"title_type\", \"genre\", \"mpaa_rating\", \"critics_rating\", \"audience_rating\"),\n                  selected = \"mpaa_rating\")\n      \n    ),\n    \n    # Output: Show scatterplot\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y,\n                                     color = input$z)) +\n      geom_point()\n  })\n  \n  }\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n2.2.11 Practice: Extend the UI further\nThe potential variables the user can select for the x and y axes and color currently appear in the UI of the app the same way that they are spelled in the data frame header. However we might want to label them in a way that is more human readable. We can achieve this using named vectors for the choices argument, in the format of \"Human readable label\" = \"variable_name\".\n\n2.2.11.1 Your turn\n\nFill in the blanks in the code below with human readable labels for x and y inputs.\nRe-create the selectInput widget for color, z, with options \"title_type\", \"genre\", \"mpaa_rating\", \"critics_rating\", and \"audience_rating\", default selection \"mpaa_rating\" just like in the previous exercise, but this time use human readable labels as well.\n\n\nComplete this exercise by opening up the RStudio Project titled 1-2b Extend the UI further within your RStudio Cloud Workspace\n Go to RStudio Cloud Workspace\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  \n  sidebarLayout(\n    \n    # Inputs: Select variables to plot\n    sidebarPanel(\n      \n      # Select variable for y-axis\n      selectInput(inputId = \"y\", \n                  label = \"Y-axis:\",\n                  choices = c(___ = \"imdb_rating\", \n                              ___ = \"imdb_num_votes\", \n                              ___ = \"critics_score\", \n                              ___ = \"audience_score\", \n                              ___ = \"runtime\"), \n                  selected = \"audience_score\"),\n      \n      # Select variable for x-axis\n      selectInput(inputId = \"x\", \n                  label = \"X-axis:\",\n                  choices = c(___ = \"imdb_rating\", \n                              ___ = \"imdb_num_votes\", \n                              ___ = \"critics_score\", \n                              ___ = \"audience_score\", \n                              ___ = \"runtime\"), \n                  selected = \"critics_score\"),\n      \n      # Select variable for color\n      selectInput(inputId = \"z\", \n                  label = \"Color:\",\n                  choices = ___, \n                  selected = ___)\n      \n    ),\n    \n    # Output: Show scatterplot\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y,\n                                     color = input$z)) +\n      geom_point()\n  })\n  \n  }\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  \n  sidebarLayout(\n    \n    # Inputs: Select variables to plot\n    sidebarPanel(\n      \n      # Select variable for y-axis\n      selectInput(inputId = \"y\", \n                  label = \"Y-axis:\",\n                  choices = c(\"IMDB rating\"          = \"imdb_rating\", \n                              \"IMDB number of votes\" = \"imdb_num_votes\", \n                              \"Critics score\"        = \"critics_score\", \n                              \"Audience score\"       = \"audience_score\", \n                              \"Runtime\"              = \"runtime\"), \n                  selected = \"audience_score\"),\n      \n      # Select variable for x-axis\n      selectInput(inputId = \"x\", \n                  label = \"X-axis:\",\n                  choices = c(\n                    \"IMDB rating\"          = \"imdb_rating\", \n                    \"IMDB number of votes\" = \"imdb_num_votes\", \n                    \"Critics score\"        = \"critics_score\", \n                    \"Audience score\"       = \"audience_score\", \n                    \"Runtime\"              = \"runtime\"), \n                  selected = \"critics_score\"),\n      \n      # Select variable for color\n      # Select variable for color\n      selectInput(inputId = \"z\", \n                  label = \"Color by:\",\n                  choices = c(\n                    \"Title type\" = \"title_type\", \n                    \"Genre\" = \"genre\", \n                    \"MPAA rating\" = \"mpaa_rating\", \n                    \"Critics rating\" = \"critics_rating\", \n                    \"Audience rating\" = \"audience_rating\"),\n                  selected = \"mpaa_rating\")\n      \n    ),\n    \n    # Output: Show scatterplot\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y,\n                                     color = input$z)) +\n      geom_point()\n  })\n  \n  }\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "hello.html#server-function",
    "href": "hello.html#server-function",
    "title": "2  Hello Shiny",
    "section": "2.3 Server function",
    "text": "2.3 Server function\nNow that you’ve had some practice with the UI, it’s time to move on to the server function.\nAgain, before we get into the details, let’s remind ourselves of the anatomy of a Shiny app. The basic task of the server function is to define the relationship between inputs and outputs.\n\n2.3.1 Here again is the app that we are working with in this module\nEarlier we saw how to build the UI of this app, and we also noted that each input was tagged with an inputId that can be used to refer to them in the server.\n\n\n\n\n\n\n\n\n\n\n\n2.3.2 This is the server function code for this app\nOnce again there is a lot going on here to parse at once, so in the following sections we take a closer look at the function.\n\n\n\n\n\n\n\n\n\n\n\n2.3.3 At the outermost layer\n\n\n\n\n\n\n\n\n\nWe define our server function which takes two arguments: an input and an output. Both of these are named lists.\nThe server function accesses inputs selected by the user to perform computations and specifies how outputs laid out in the UI should be updated.\nThe server function can take on one more argument, session, which is an environment that can be used to access information and functionality relating to the session. However this concept is beyond the scope of this tutorial, so for now we’ll stick to server functions that only have input and output arguments.\n\n\n2.3.4 output\nOur simple app had only one output – a plot. So our server function contains the logic necessary to build this plot.\n\n\n\n\n\n\n\n\n\nThe renderPlot() function specifies how the plot output should be updated. Let’s take a look at what is happening in the renderPlot() function first.\n\n\n2.3.5 renderPlot()\n\n\n\n\n\n\n\n\n\nThis is good ol’ ggplot2 code! So even if you’re new to shiny, if you’ve previously used ggplot2 for plotting in R, this syntax should look familiar to you.\nOne aspect of the syntax that might be new, however, is how the x and y variables are defined. They come from the input list that is built in the UI.\n\n\n2.3.6 Inputs\nHere is the relevant UI and server code.\n\n\n\n\n\n\n\n\n\nInput x and y come from the selectInput() widgets, and map to the x and y arguments of the plot aesthetics.\n\n\n2.3.7 Rules of server functions\nThere are three rules of building server functions:\n\nAlways save objects to display to the named output list, i.e. something of the form output$xx, where xx is the plot you want to display.\nAlways build objects to display with one of the render*() functions, like we built our plot with renderPlot().\nUse input values from the named input list, with input$xx.\n\n\n\n2.3.8 Output types\nJust like various inputs, Shiny also provides a wide selection of output types each of which works with a render function.\n\n\n\n\n\n\n\n\n\nFor example, in our app we used the renderPlot() function to build our reactive plot (we’ll get to what I mean by reactive in a second) and laid out the plot with the plotOutput() function.\n\n\n\n\n\n\n\n\n\nShiny knows to match these two together as they use the same outputID, scatterplot.\nIn the following exercises you’ll get a chance to work with other render/output function pairs to add more elements to your app.\n\n\n2.3.9 Practice: Matching inputs and outputs\nHere is a simple Shiny app. Try entering some text and observe how the text is displayed back to you after a short pause.\n\n\n\n\n\nInput some text here:\n\n\nText is shown below:\n\n\n\n\n#{r, context = \"server\", eval = TRUE} # output$user_text <- renderText({ input$custom_text }) #\n\nThe code for this app is given below, with a few pieces missing (indicated with ___). Each of the blanks are numbered, e.g. ([1], [2], etc.)\n\nlibrary(shiny)\n\nui <- fluidPage(\n\n  textInput(\n    inputId = \"custom_text\",\n    label = \"_[1]_\"\n  ),\n\n  strong(\"Text is shown below:\"),\n\n  _[2]_(outputId = \"_[3]_\")\n\n)\n\nserver <- function(input, output, session){\n\n  output$user_text <- renderText({ input$_[4]_ })\n\n}\n\nshinyApp(ui = ui, server = server)\n\n#{r mc-2} #question(\"Which of the following is false?\", #  answer('`[1]` should be `\"Input some text here:\"`', #         message = \"Take a look at the app, what text is #shown to the user above the text input area?\"), #  answer('`[2]` should be `textOutput`',  #         message = \"Check out the Shiny cheatsheet for pairs #of input and output functions\"), #  answer('`[3]` should be `\"custom_text\"`', correct = TRUE), #  answer('`[4]` should be `\"custom_text\"`', #         message = \"What is the ID of the input that should #be rendered?\"), #  allow_retry = TRUE #) #\n\n\n2.3.10 Reactivity\nLet’s also briefly discuss reactivity.\n\n\n\n\n\n\n\n\n\nIt’s easy to build interactive applications with Shiny, but to get the most out of it, you’ll need to understand the reactive programming scheme used by Shiny.\nIn a nutshell Shiny automatically updates outputs, such as plots, when inputs that go into them change.\n\n\n2.3.11 Putting all the pieces together\nBefore we wrap up this section, I should also mention the last component of each Shiny app, which is a call to the aptly named shinyApp() function, which puts the UI and the server pieces together to create a Shiny app object.\n\n\n\n\n\n\n\n\n\nTime to put this all into practice!\n\n\n2.3.12 Practice: Rules of server functions\nWhich of the following is not true about server functions?\n#{r mc-3} #question(\"Which of the following is not true about server functions?\", #  answer(\"Server functions should include a call to #`runApp()`\", #    correct = TRUE, #    message = \"The `runApp()` function can be used in the Console to run a Shiny application, as an alternative to the Run App button in the RStudio IDE.\" #  ), #  answer(\"Objects to be displayed should be saved to #`output$`\"), #  answer(\"Reactive objects should be built with `render*()` functions\"), #  answer(\"Input values should be referred to with `input$`\"), #  allow_retry = TRUE, #  random_answer_order = TRUE #) #\n\n\n2.3.13 Practice: Fix it up\nBelow is the code for the Shiny app we built earlier, however currently the code is broken. Specifically there are errors in the definition of the server function as well as in the mainPanel of the UI.\n\n2.3.13.1 Your turn\n\nReview the app and identify errors in the code.\n\nHint: Refer back to the rules of server functions.\n\nDo the render functions match the output functions? If not, make the appropriate change and try running the app. Are there any remaining errors?\nAre the inputs referred to using the correct syntax? If not, make the appropriate change and try running the app. Are there any remaining errors?\nAre the outputs referred to using the correct names? If not, make the appropriate change and try running the app. Are there any remaining errors?\n\n\nNavigate to the project called 1-3 Fix it up after clicking the button below\n Go to RStudio Cloud Workspace\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n\n    # Inputs: Select variables to plot\n    sidebarPanel(\n\n      # Select variable for y-axis\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics score\" = \"critics_score\",\n          \"Audience score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      # Select variable for x-axis\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics score\" = \"critics_score\",\n          \"Audience score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      # Select variable for color\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA rating\" = \"mpaa_rating\",\n          \"Critics rating\" = \"critics_rating\",\n          \"Audience rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      )\n    ),\n\n    # Output: Show scatterplot\n    mainPanel(\n      plotOutput(outputId = \"scatterPlot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- renderTable({\n\n    ggplot(data = movies, aes_string(x = x, y = y, color = z)) +\n      geom_point()\n\n  })\n\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "hello.html#recap",
    "href": "hello.html#recap",
    "title": "2  Hello Shiny",
    "section": "2.4 Recap",
    "text": "2.4 Recap\nLet’s quickly recap what we have learned in this chapter.\n\n2.4.1 \nEvery Shiny app has a webpage that the user visits, and behind this webpage there is a computer that serves this webpage by running R.\n\n\n\n\n\n\n\n\n\n\n\n2.4.2 \nWhen running your app locally, the computer serving your app is your computer.\n\n\n\n\n\n\n\n\n\n\n\n2.4.3 \nWhen your app is deployed, the computer serving your app is a web server.\n\n\n\n\n\n\n\n\n\n\n\n2.4.4 \nEach app is comprised of two components, a UI and a server.\n\n\n\n\n\n\n\n\n\n\nThe UI is ultimately built with HTML, CSS, and JavaScript. However, you as the Shiny developer do not need to know these languages. Shiny lets R users write user interfaces using a simple, familiar-looking API. However there are no limits to customization for advanced users who are familiar with these languages.\nThe server function contains the instructions to map user inputs to outputs.\n\nI often think of the UI as containing syntax specific to Shiny, and the server as containing R code you might already be familiar with – with some Shiny functions added to achieve reactivity.\n\n\n2.4.5 Tip: Change display\nIn this tutorial you will be developing your apps in RStudio Cloud projects, but once you’re done with the tutorial you might consider developing your apps in the RStudio IDE, which has some some handy-dandy functionality for running and viewing your apps.\nRStudio will automatically recognize R scripts that contain ui and server components and that end with a call to the shinyApp() function and will make available the Run App button. You can choose to run your app in a new window, or in the viewer pane of your RStudio window.\n\n\n\n\n\n\n\n\n\n\n\n2.4.6 Tip: Close an app\nWhen you are done with an app, you can terminate the session by clicking the red stop button in your viewer pane.\n\n\n\n\n\n\n\n\n\n\n\n2.4.7 \nThat’s all for this module! In the next module we discuss inputs, outputs, and rendering functions in further detail."
  },
  {
    "objectID": "flow.html#reactive-flow",
    "href": "flow.html#reactive-flow",
    "title": "3  Reactive Flow",
    "section": "3.1 Reactive flow",
    "text": "3.1 Reactive flow\n\n3.1.1 Reactivity, in spreadsheets\nOne familiar way of thinking about reactivity is to think in the context of a spreadsheet, like Google Sheets or Microsoft Excel.\n\n\n\n\n\n\n\n\n\n\n\n3.1.2 \nSuppose you write a value into a cell in a spreadsheet…\n\n\n\n\n\n\n\n\n\n\n\n3.1.3 \nand then in another cell you write a formula that depends on that cell.\n\n\n\n\n\n\n\n\n\n\n\n3.1.4 \nFirst, the formula is calculated with the value you originally typed.\n\n\n\n\n\n\n\n\n\n\n\n3.1.5 \nNow when you change the value of the original cell, the result of the formula will automatically update, or in other words, react to this change.\n\n\n\n\n\n\n\n\n\n\n\n3.1.6 Reactions\nIn a Shiny app reactivity happens in a similar fashion.\nSuppose you have a sliderInput in your app with the inputId of alpha. The value of this input is stored in input$alpha.\n\n\n\n\n\n\n\n\n\nSo when the user moves around the slider, the value of the alpha input is updated in the input list.\n\n\n3.1.7 Reactivity 101\nReactivity automatically occurs when an input value is used to render an output object, i.e. in the server function below the plot is re-rendered when the value of input$alpha changes based on user input. You, as the app developer, do not need to write code that says “Update the plot every time the value of input$alpha changes”, Shiny automatically takes care of this for you in the render*() function.\n\n\n\n\n\n\n\n\n\n\n\n3.1.8 Reactive flow\nHere is a roadmap of the reactive flow in Shiny, though for now we’ll just focus on the straight path between an input and an output, and discuss the other features later in the course.\n\n\n\n\n\n\n\n\n\n\n\n3.1.9 Reactive flow, simplified\n\n\n\n\n\n\n\n\n\nThe user selects an input, this input goes through some expression in the server, and an output is rendered. Each time the user changes their input selection, the expression that generates the output will automatically re-execute, and the relevant output will be re-rendered based on the new value of the input.\nIn a Shiny application, there’s no need to explictly describe the relationships between inputs and outputs and tell R what to do when each input changes, Shiny automatically handles these details for you.\n\n\n3.1.10 Practice: Building a reactive widget\nAs we saw in the previous sections, reactivity is established by linking an input with an output via a render*() function.\n\n3.1.10.1 Your turn\n\nAdd a new input widget, a sliderInput, that controls the transparency of the plotted points. This widget should have the ID alpha and its values should range between 0 and 1. You can decide what the displayed label and initial value of the slider should be.\nMake the associated update in the server function.\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-1a Building a reactive widget in your RStudio Workspace\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  \n  sidebarLayout(\n    \n    sidebarPanel(\n      \n      selectInput(inputId = \"y\", \n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"), \n                  selected = \"audience_score\"),\n      \n      selectInput(inputId = \"x\", \n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"), \n                  selected = \"critics_score\"),\n      \n      # Set alpha level\n      sliderInput(inputId = ___, \n                  label = ___, \n                  min = ___, max = ___, \n                  value = ___)\n    ),\n    \n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point(alpha = ___)\n  })\n  \n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"critics_score\"\n      ),\n\n      sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.5\n      )\n    ),\n\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point(alpha = input$alpha)\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n3.1.11 Practice: Dude, where’s my plot?\nThe server function of this app builds two plots, scatterplot and densityplot, however the app only displays one.\n\n3.1.11.1 Your turn\n\nRun the app and identify which plot is missing\nMake the necessary update to the app UI to display the missing plot\nReduce the height of the new plot using the height argument in the plotOutput() function (suggested height: height = 200)\n\nHint: Make sure you place commas as appropriate.\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-1b Dude wheres my plot in your RStudio Workspace\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  \n  sidebarLayout(\n    \n    sidebarPanel(\n      \n      selectInput(inputId = \"y\",\n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"audience_score\"),\n      \n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"critics_score\")\n    ),\n    \n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n  \n  output$densityplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x)) +\n      geom_density()\n  })\n  \n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"critics_score\"\n      )\n    ),\n\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\"),\n      plotOutput(outputId = \"densityplot\", height = 200)\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n\n  output$densityplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x)) +\n      geom_density()\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "flow.html#ui-inputs",
    "href": "flow.html#ui-inputs",
    "title": "3  Reactive Flow",
    "section": "3.2 UI Inputs",
    "text": "3.2 UI Inputs\n\n3.2.1 \nThe goal of this section is to build familiarity with a few UI input functions.\n\n\n3.2.2 \nOnce again, we’ll build on our simple movie browser app.\n\n\n\n\n\n\n\n\n\n\n\n3.2.3 \nShiny provides a wide selection of input widgets. The Shiny cheatsheet is a great place to see a list of them all at once.\nOnce you know which one you want to use, you can find out more about it in the package documentation. You’ll also get a chance to work with some of them in the following exercises.\n\n\n\n\n\n\n\n\n\n\n\n3.2.4 checkboxInput\nLet’s start with a checkboxInput().\nSuppose we want to add checkbox input to our app to specify whether the data plotted should be shown in a data table. We need to make three modifications to our app to accomplish this.\n\nIn the ui: Add an input widget that the user can interact with to check/uncheck the box.\n\n1.In the ui: Add an output to the UI defining where the data table should appear.\n\nIn the server function: Add a reactive expression that creates the data table if the checkbox is checked.\n\nWe’ll go through these steps one by one.\n\n\n3.2.5 1. ui: Add an input widget that the user can interact with to check/uncheck the box\n\n# Show data table\ncheckboxInput(inputId = \"show_data\",\n              label = \"Show data table\", \n              value = TRUE)\n\n\nThe first argument is the inputId, which we can define to be anything we want, but short and informative names are the best.\nNext is the label, which is the user facing description of the widget.\nAnd last is the value, the initial value of the widget. TRUE means the box is initially checked. If you want it to not be checked initially, you’d set it to FALSE instead.\n\n\n\n3.2.6 Watch for commas!\nA cautionary tale before we move on – watch for your commas! Remember that this widget definition goes in the sidebarPanel(). In this panel we separate out widget with commas.\n\nsidebarPanel(\n    # Select variable for y-axis \n    selectInput(inputId = \"y\", label = \"Y-axis:\",\n                choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                selected = \"audience_score\"),  \n    # Select variable for x-axis\n    selectInput(inputId = \"x\", label = \"X-axis:\",\n                choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\",  \n\"audience_score\", \"runtime\"),\nselected = \"critics_score\"),\n    # Show data table \n    checkboxInput(inputId = \"show_data\",\n                  label = \"Show data table\", value = TRUE)   \n )\n\n\n\n\n\n\n\n\n\n\nFor example:\n\nThe first is the selectInput widget for y, then we have a comma,\nthen another selectInput and another comma, and\nthen our new checkboxInput and no comma after it since it’s the last item in the list.\n\n\n\n3.2.7 2. ui: Add an output to the UI defining where the data table should appear.\n\nmainPanel(\n  # Show scatterplot\n  plotOutput(outputId = \"scatterplot\"), \n  # Show data table\n  dataTableOutput(outputId = \"movestable\")\n)\n\nThe second step was to add an output to the UI defining where the data table should appear. Note that for this we’re using the dataTableOutput() function.\nThis function takes one argument, the outputId. Again, you can define to be anything we want, but short and informative names are the best.\n\n\n3.2.8 3. server: Add a reactive expression that creates the data table if the checkbox is checked.\n\n# Print data table if checked \noutput$moviestable <- renderDataTable({\n  if(input$show_data){\n    DT::datatable(data = movies %>% select(1:7),\n                  options = list(pageLength = 10),\n                  rownames = FALSE)\n  } \n})\n\nLastly, in our server, we describe how this table should be calculated. We use the renderDataTable() function to build this table.\nNote that the first line of code in the function is an if statement, telling the app to only do this if input$show_data is TRUE. We also specify some other arguments to datatable(), mostly for cosmetic reasons.\n\n\n3.2.9 \nHere is the resulting app, with the box checked:\n\n\n\n\n\n\n\n\n\nand box unchecked:\n\n\n\n\n\n\n\n\n\n\n\n3.2.10 Scoping\nA quick note on scoping:\nWe saw that the data loaded on top of the Shiny app, outside of ui and server definitions, is visible to the server. That’s how we were able to plot the data simply by referring to the data frame by name. The data frame is actually also visible to the UI as well. So our UI inputs could be defined programmatically.\nWe’ll give an example for this, not with an interactive widget but instead with a static HTML statement:\n\n# Display number of observations\nHTML(paste0(\"The dataset has \", nrow(movies), \n            \"observations.\"))\n\n\n\n3.2.11 Practice: Add numericInput\nThe app below allows users to randomly select a desired number of movies, and displays some information on the selected movies in a tabular output. This table is created using a new function, renderDataTable(), but for now we will keep our focus on the numericInput() widget. We will also learn to define variables outside of the app so that they can be used in multiple spots to make our code more efficient.\n\n3.2.11.1 Your turn\n\nMake sure entries in the sidebarPanel() are separated by commas\nCalculate n_total (total number of movies in the data set) as nrow(movies) before defining the UI.\nUse n_total instead of the hard-coded \"651\" in the helper text.\nAdd min and max values to the numericInput() widget, where min is 1 and max is n_total.\nChange the default value of the sample size to 30.\nChange the step parameter of numericInput() such that values increase by 1 (instead of 10) when the up arrow is clicked in the numeric input widget in the app UI.\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-2a Add numericInput in your RStudio Workspace\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(DT)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  \n  sidebarLayout(\n    \n    sidebarPanel(\n      \n      HTML(paste(\"Enter a value between 1 and\", \"651\"))\n      \n      numericInput(inputId = \"n\",\n                   value = 3,\n                   step = 10)\n      \n    ),\n    \n    mainPanel(\n      DT::dataTableOutput(outputId = \"moviestable\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$moviestable <- DT::renderDataTable({\n    movies_sample <- movies %>%\n      sample_n(input$n) %>%\n      select(title:studio)\n    DT::datatable(data = movies_sample, \n                  options = list(pageLength = 10), \n                  rownames = FALSE)\n  })\n  \n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(DT)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\nn_total <- nrow(movies)\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      HTML(paste(\"Enter a value between 1 and\", n_total)),\n\n      numericInput(\n        inputId = \"n\",\n        label = \"Sample size:\",\n        value = 30,\n        min = 1, max = n_total,\n        step = 1\n      )\n    ),\n\n    mainPanel(\n      dataTableOutput(outputId = \"moviestable\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  output$moviestable <- renderDataTable({\n    movies_sample <- movies %>%\n      sample_n(input$n) %>%\n      select(title:studio)\n    DT::datatable(\n      data = movies_sample,\n      options = list(pageLength = 10),\n      rownames = FALSE\n    )\n  })\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n3.2.12 Practice: req\nThe app below is the one you developed in the previous exercise.\n\nHighlight the code and run it.\nThen, delete the numeric value.\n\nYou will encounter an error: Error: size is not a numeric or integer vector.\nIn order to avoid such errors, which users of your app could very easily encounter, we need to hold back the output from being calculated if the input is missing.\nThe req() function is the simplest and best way to do this, it ensures that values are available (“truthy”) before proceeding with a calculation or action. If any of the given values is not truthy, the operation is stopped by raising a “silent” exception (not logged by Shiny, nor displayed in the Shiny app’s UI).\n\n3.2.12.1 Your turn\n\nAdd req(input$n) in the renderDataTable() function in the server before movies_sample is calculated.\nRun your app again and delete the input sample size to confirm that the error doesn’t appear, and neither does the output table.\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-2b req in your RStudio Workspace\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\noptions(\"shiny.sanitize.errors\" = FALSE) # Turn off error sanitization\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\nn_total <- nrow(movies)\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  \n  sidebarLayout(\n    \n    sidebarPanel(\n      \n      HTML(paste(\"Enter a value between 1 and\", n_total)),\n      \n      numericInput(inputId = \"n\",\n                   label = \"Sample size:\",\n                   value = 30,\n                   min = 1, max = n_total,\n                   step = 1)\n      \n    ),\n    \n    mainPanel(\n      DT::dataTableOutput(outputId = \"moviestable\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$moviestable <- DT::renderDataTable({\n    movies_sample <- movies %>%\n      sample_n(input$n) %>%\n      select(title:studio)\n    datatable(data = movies_sample, \n              options = list(pageLength = 10), \n              rownames = FALSE)\n  })\n  \n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n\n\n\n\n\n\n3.2.13 Practice: Select to selectize\nThe app below can be used to display movies from selected studios. Currently you can only choose one studio, but we’ll modify it to allow for multiple selections. Additionally, there are 211 unique studios represented in this dataset, we need a better way to select than to scroll through such a long list, and we address that with the selectize option, which will suggest names of studios as you type them.\n\n3.2.13.1 Your turn\n\nView the help function for the selectInput widget by typing ?selectInput in the console, and figure out how to enable the selectize and multiple selection options (or whether they are enabled by default).\nBased on your findings add the necessary arguments to the selectInput widget.\nAdd a call to the req() function in the server, just like you did in the previous exercise but this time requiring that input$studio be available.\nRun the app and (1) confirm that you can select multiple studios, (2) start typing “Warner Bros” to confirm selectize works, and (3) delete all selections to confirm req is preventing an error from being displayed.\nNow try with selectize = FALSE: Start typing “Warner Bros” and see how the behaviour changed.\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-2c Select to selectize in your RStudio Workspace\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(DT)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\nall_studios <- sort(unique(movies$studio))\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    \n    sidebarPanel(\n      selectInput(inputId = \"studio\",\n                  label = \"Select studio:\",\n                  choices = all_studios,\n                  selected = \"20th Century Fox\")\n      \n    ),\n    \n    mainPanel(\n      DT::dataTableOutput(outputId = \"moviestable\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$moviestable <- renderDataTable({\n    movies_from_selected_studios <- movies %>%\n      filter(studio == input$studio) %>%\n      select(title:studio)\n    DT::datatable(data = movies_from_selected_studios, \n              options = list(pageLength = 10), \n              rownames = FALSE)\n  })\n  \n}\n\n# Create a Shiny app object ----------------------------------------------------\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(DT)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\nall_studios <- sort(unique(movies$studio))\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n\n    # Input(s)\n    sidebarPanel(\n      selectInput(\n        inputId = \"studio\",\n        label = \"Select studio:\",\n        choices = all_studios,\n        selected = \"20th Century Fox\",\n        multiple = TRUE\n      )\n    ),\n\n    # Output(s)\n    mainPanel(\n      dataTableOutput(outputId = \"moviestable\")\n    )\n  )\n)\n\n# Server\nserver <- function(input, output, session) {\n\n  # Create data table\n  output$moviestable <- renderDataTable({\n    req(input$studio)\n    movies_from_selected_studios <- movies %>%\n      filter(studio %in% input$studio) %>%\n      select(title:studio)\n    DT::datatable(\n      data = movies_from_selected_studios,\n      options = list(pageLength = 10),\n      rownames = FALSE\n    )\n  })\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n3.2.14 Practice: Convert dateInput to dateRangeInput\nThe app below can be used to display movies from a particular date onwards. Instead we would like to select movies between two given dates. Hence we need to convert the dateInput widget to dateRangeInput. This input will yield a vector (input$date) of length two: the first element is the start date and the second is the end date.\n\n3.2.14.1 Your turn\n\nReview the help files for the two widgets by typing ?dateInput and ?dateRangeInput in the console.\nUpdate dateInput to dateRangeInput, instead of just a start date (value) specify start and end dates, Jan 1, 2013 and Jan 1, 2014, respectively.\nUpdate the explanatory text to reflect the new functionality of the app.\nChange the startview to \"year\" to make it a bit easier for the user to navigate the calendar.\nUpdate how subsetting is being done in the server function: we need movies released at or after the start date and at or before the end date.\nAdd the necessary req statement to the server to stop the app from trying to create a plot when no dates are specified.\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-2d Convert dateInput to dateRangeInput in your RStudio Workspace\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\nmin_date <- min(movies$thtr_rel_date)\nmax_date <- max(movies$thtr_rel_date)\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    \n    sidebarPanel(\n      \n      HTML(paste0(\"Movies released since the following date will be plotted. \n                 Pick a date between \", min_date, \" and \", max_date, \".\")),\n      \n      br(), br(),\n      \n      dateInput(inputId = \"date\",\n                label = \"Select date:\",\n                value = \"2013-01-01\",\n                min = min_date, max = max_date)\n    ),\n    \n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- renderPlot({\n    movies_selected_date <- movies %>%\n      filter(thtr_rel_date >= as.POSIXct(input$date))\n    ggplot(data = movies_selected_date, aes(x = critics_score, y = audience_score, color = mpaa_rating)) +\n      geom_point()\n  })\n  \n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\nmin_date <- min(movies$thtr_rel_date)\nmax_date <- max(movies$thtr_rel_date)\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      HTML(paste0(\"Movies released between the following dates will be plotted. \n                  Pick dates between \", min_date, \" and \", max_date, \".\")),\n\n      br(), br(),\n\n      dateRangeInput(\n        inputId = \"date\",\n        label = \"Select dates:\",\n        start = \"2013-01-01\", end = \"2014-01-01\",\n        min = min_date, max = max_date,\n        startview = \"year\"\n      )\n    ),\n\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- renderPlot({\n    req(input$date)\n    movies_selected_date <- movies %>%\n      filter(thtr_rel_date >= as.POSIXct(input$date[1]) & thtr_rel_date <= as.POSIXct(input$date[2]))\n    ggplot(data = movies_selected_date, aes(x = critics_score, y = audience_score, color = mpaa_rating)) +\n      geom_point()\n  })\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "flow.html#render-functions",
    "href": "flow.html#render-functions",
    "title": "3  Reactive Flow",
    "section": "3.3 render*() functions",
    "text": "3.3 render*() functions\n\n3.3.1 \nThe goal of this section is to build familiarity with a few rendering functions.\n\n\n3.3.2 \nAs we mentioned earlier in the course, Shiny provides a wide selection of output types, each of which works with a render function. We looked at the renderPlot() function before.\n\n\n\n\n\n\n\n\n\n\n\n3.3.3 \nNow let’s take a look at the renderTable() function.\n\n\n\n\n\n\n\n\n\n\n\n3.3.4 \nThis is the app you’ve seen numerous times so far that we will use as our starting point.\n\n\n\n\n\n\n\n\n\n\n\n3.3.5 \nAnd this is the final app that we want to achieve, with a summary table beneath the plot.\n\n\n\n\n\n\n\n\n\n\n\n3.3.6 renderTable\nSo we want to add a summary table beneath the plot displaying summary statistics for a new variable we’ll create: score_ratio, the ratio of audience scores to critics scores.\n\n\n\nWe need to make four modifications to our app to accomplish this.\n\nCalculate the new variable\nIn the ui: Add an input widget that the user can interact with to check boxes for selected title types.\nIn the ui: Add an output defining where the summary tables should appear.\nIn the server function: Add a reactive expression that creates the summary table.\n\nWe’ll go through these steps one by one.\n\n\n3.3.7 1. Calculate the new variable.\n\n# Create new variable:\n# ratio of critics and audience scores\nmovies <- movies %>%\n  mutate(score_ratio = audience_score / critics_score)\n\nFirst is creating the new variable, which we can do outside of the ui and the server so it’s calculated once when our app launches.\nThere are many ways one can create the new variable in R. We do so here using the mutate() function from the dplyr package.\n\n\n3.3.8 2. ui: Add an input widget that the user can interact with to check boxes for selected title types.\n\n# Subset for title types\ncheckboxGroupInput(inputId = \"selected_title_type\", \n                   label = \"Select title type:\", \n                   choices = levels(moves$title_type),\n                   selected = levels(movies$title_type))\n\n\nThe first argument is the inputId.\nNext is the user facing label.\nThird, we define the choices. Previously we manually entered the choices. We present an alternative approach here, directly using information from the dataset. Specifically, the choices we want are the levels of the title_type variable. And by default we select all of them.\n\n\n\n3.3.9 3. ui: Add an output defining where the summary tables should appear.\n\nmainPanel(\n  # Show scatterplot\n  plotOutput(outputId = \"scatterplot\"), \n  # Show data table\n  tableOutput(outputId = \"summarytable\")\n)\n\nWe use the tableOutput() function for this. This function takes one argument, the outputId.\n\n\n3.3.10 4. server: Add a reactive expression that creates the summary table.\nLastly, in the server, we describe how this table should be calculated with the renderTable() function.\n\noutput$summarytable <- renderTable(\n  {\n    movies %>%\n      filter(title_type %in% input$selected_title_type) %>%\n      group_by(mpaa_rating) %>%\n      summarise(mean_score_ratio = mean(score_ratio), SD = sd(score_ratio), n = n())\n  },\n  striped = TRUE,\n  spacing = \"l\",\n  align = \"lccr\",\n  digits = 4,\n  width = \"90%\",\n  caption = \"Score ratio (audience / critics' scores) summary statistics by MPAA rating.\"\n)\n\nNote that the name of the output created by the render function should match the name we used for the output in the ui (summarytable).\nThe first argument is the expression that returns an R object in tabular form.\n\n  {\n    movies %>%\n      filter(title_type %in% input$selected_title_type) %>%\n      group_by(mpaa_rating) %>%\n      summarise(mean_score_ratio = mean(score_ratio), SD = sd(score_ratio), n = n())\n  }\n\nNote that we wrap the expression with curly braces. The expression first filters for the selected title types. Since this is a user selection, the information is in the input list generated in the ui.\nThen, the expression groups the data by MPAA rating, and then calculates summary statistics like means, standard deviations, and sample sizes for each level of MPAA ratings.\n\n\n3.3.11 \nIf we stopped here and didn’t include any of the following arguments, the app would look something like this:\n\n\n\n\n\n\n\n\n\nBut we want our table to look like this:\n\n\n\n\n\n\n\n\n\n\n\n3.3.12 \nIn order to achieve this look, we add additional arguments to our render* function.\n\nstriped = TRUE, spacing = \"l\", align = \"lccr\", digits = 4, width = \"90%\",\ncaption = \"Score ratio (audience / critics' scores) summary statistics by MPAA rating.\"\n\n\nstriped = TRUE for alternating color rows\nspacing = \"l\" for larger row heights\nthe align argument for left, right, or center alignment of columns\ndigits for number of decimal places to display\nwidth for, well, width of the table output\nand lastly a caption.\n\n\n\n3.3.13 Recap\n\nShiny has a variety of render*() functions with corresponding *Output() functions to create and display outputs.\nrender*() functions can take on multiple arguments, the first being the expression for the desired output.\nThe expression in the render*() function should be wrapped in curly braces.\n\nAlright, it’s time for you to practice render*() functions!\n\n\n3.3.14 Practice: Missing renderPlot()\nThe following app is one you’ve seen before – it creates a scatterplot of two variables selected by the user. However it’s missing a crucial component, and hence the plot is not rendered.\n\n3.3.14.1 Your turn\n\nFix the app code by adding the missing component, and run to confirm that it works.\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-3a Missing renderPlot in your RStudio Workspace\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    \n    sidebarPanel(\n      \n      selectInput(inputId = \"y\", \n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"), \n                  selected = \"audience_score\"),\n      \n      selectInput(inputId = \"x\", \n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"), \n                  selected = \"critics_score\")\n    ),\n    \n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n    geom_point()\n  \n  }\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"critics_score\"\n      )\n    ),\n\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n3.3.15 Practice: Add renderText()\nIn this app, the user selects x and y variables for the scatterplot. We will extend the app to also include a textOutput which prints the correlation between the two selected variables as well some informational text.\n\n3.3.15.1 Your turn\n\nCreate the text to be printed using the paste() function: “Correlation = ____. Note: If the relationship between the two variables is not linear, the correlation coefficient will not be meaningful.”\nPlace the text within the renderText() function, and assign to output$text$.\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-3b Add renderText in your RStudio Workspace.\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n\n  sidebarLayout(\n    \n    sidebarPanel(\n      \n      selectInput(inputId = \"y\", \n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"), \n                  selected = \"audience_score\"),\n      \n      selectInput(inputId = \"x\", \n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"), \n                  selected = \"critics_score\")\n    ),\n    \n    mainPanel(\n      plotOutput(outputId = \"scatterplot\"),\n      textOutput(outputId = \"correlation\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n  \n  # Create text output stating the correlation between the two ploted \n  output$correlation <- ___\n\n  s}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"critics_score\"\n      )\n    ),\n\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\"),\n      textOutput(outputId = \"correlation\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n\n  # Create text output stating the correlation between the two ploted\n  output$correlation <- renderText({\n    r <- round(cor(movies[, input$x], movies[, input$y], use = \"pairwise\"), 3)\n    paste0(\n      \"Correlation = \", r,\n      \". Note: If the relationship between the two variables is not linear, the correlation coefficient will not be meaningful.\"\n    )\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "flow.html#ui-outputs",
    "href": "flow.html#ui-outputs",
    "title": "3  Reactive Flow",
    "section": "3.4 UI outputs",
    "text": "3.4 UI outputs\n\n3.4.1 \nWe’ve seen UI outputs before, and in this section we dive deeper into the plotOutput() function to build an interactive graph.\n\n\n3.4.2 \nOnce again we’re going to start with this app.\n\n\n\n\n\n\n\n\n\n\n\n3.4.3 \nAnd we’ll add functionality to the app so that movies corresponding to the selected points on the plot via brushing are displayed in a data table beneath the plot.\n\n\n\n\n\n\n\n\n\n\n\n3.4.4 plotOutput()\nWe need to make three modifications to our app to accomplish this.\n\nui: Add functionality to plotOutput to select points via brushing.\nui: Add an output defining where the data table should appear.\nserver: Add a reactive expression that creates the data table for the selected points.\n\nLet’s go through these steps one by one.\n\n\n3.4.5 1. ui: Add functionality to plotOutput to select points via brushing.\nFirst is the brushing capability added to the plotOutput() function. Previously we’ve only passed one argument to the plotOutput() function. This time we’re making use its additional arguments, one of which is brush.\nProviding a string to this argument allows the user to “brush” in the plotting area. Brushing means that the user will be able to draw a rectangle in the plotting area and drag it around. Brushing will send information about the brushed area to the server. The value will then be accessible via input$plot_brush.\n\n\n3.4.6 2. ui: Add an output defining where the data table should appear.\nSecond, we use the dataTableOutput() to define where on the main panel the data table should appear.\n\n\n3.4.7 3. server: Add a reactive expression that creates the data table for the selected points.\nAnd third, in the server, we describe how this table should be calculated with the renderDataTable() function. We make use of a helper function brushedPoints(), which returns rows from a data frame which are under a brush used with plotOutput().\n\nThe first argument is the data frame from which to select rows.\nThe second argument is the input element that contains information on the brushed points.\nIn order to avoid printing all of the variables in the data frame, in the next line we select a few to display.\n\nNote that the complete expression is wrapped in curly braces again. We do this for consistency in our code as well as to make debugging easier, if need be.\n\n\n3.4.8 Practice - Hovering\nIn addition to brushing, users can also interact with plots via hovering over them.\n\n3.4.8.1 Your turn\n\nChange the brush argument to hover in the plotOutput().\nRead the article on Selecting rows of data to determine what change needs to be made in the renderDataTable() function to list the data points that the user hovers on.\nImplement this change.\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-4a Hovering in your RStudio Workspace.\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  br(),\n\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"y\", label = \"Y-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\", label = \"X-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"critics_score\"\n      )\n    ),\n\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\", brush = \"plot_brush\"),\n      DT::dataTableOutput(outputId = \"moviestable\"),\n      br()\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n\n  output$moviestable <- renderDataTable({\n    brushedPoints(movies, brush = input$plot_brush) %>%\n      select(title, audience_score, critics_score)\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  br(),\n\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"y\", label = \"Y-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"audience_score\"\n      ),\n      selectInput(\n        inputId = \"x\", label = \"X-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"critics_score\"\n      )\n    ),\n\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\", hover = \"plot_hover\"),\n      dataTableOutput(outputId = \"moviestable\"),\n      br()\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n\n  output$moviestable <- renderDataTable({\n    nearPoints(movies, input$plot_hover) %>%\n      select(title, audience_score, critics_score)\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n3.4.9 Practice - Displaying text outputs\nThe goal in this exercise is to develop an app where the user selects two variables and their relationship is visualized with a scatterplot, and averages of both variables are reported as well as the output of the linear regression predicting the variable on the y-axis from the variable in the x-axis. The code on the right only does some of these things.\n\n3.4.9.1 Your turn\n\nAdd the appropriate output UI functions and output IDs to print the elements noted in the comments in the mainPanel() of the UI and run the app. Also add commas as needed.\nIn the server function averages are calculated first and then the regression model is fit, but in the app the regression output comes before the averages. Make the necessary changes to the app so that averages are displayed above the regression output.\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-4b Displaying text outputs in your RStudio Workspace.\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    \n    sidebarPanel(\n      \n      selectInput(inputId = \"y\",\n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"audience_score\"),\n      \n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"critics_score\")\n      \n    ),\n    \n    mainPanel(\n      plotOutput(outputId = \"scatterplot\"),\n      ___(outputId = ___) # regression output\n      ___(outputId = ___) # avg of x\n      ___(outputId = ___) # avg of y\n      \n    )\n  )\n)\n# Define server ----------------------------------------------------------------\n \nserver <- function(input, output, session) {\n    \n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n  \n  output$avg_x <- renderText({\n    avg_x <- movies %>% pull(input$x) %>% mean() %>% round(2)\n    paste(\"Average\", input$x, \"=\", avg_x)\n  })\n  \n  output$avg_y <- renderText({\n    avg_y <- movies %>% pull(input$y) %>% mean() %>% round(2)\n    paste(\"Average\", input$y, \"=\", avg_y)\n  })\n  \n  output$lmoutput <- renderPrint({\n    x <- movies %>% pull(input$x)\n    y <- movies %>% pull(input$y)\n    summ <- summary(lm(y ~ x, data = movies)) \n    print(summ, digits = 3, signif.stars = FALSE)\n  })\n    \n  }\n  \n# Create the Shiny app object --------------------------------------------------\n  \nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    \n    sidebarPanel(\n      \n      selectInput(inputId = \"y\",\n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"audience_score\"),\n      \n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"critics_score\")\n      \n    ),\n    \n    # Output(s)\n    mainPanel(\n      plotOutput(outputId = \"scatterplot\"),\n      textOutput(outputId = \"avg_x\"), # avg of x\n      textOutput(outputId = \"avg_y\"), # avg of y\n      verbatimTextOutput(outputId = \"lmoutput\") # regression output\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n  \n  output$avg_x <- renderText({\n    avg_x <- movies %>% pull(input$x) %>% mean() %>% round(2)\n    paste(\"Average\", input$x, \"=\", avg_x)\n  })\n  \n  output$avg_y <- renderText({\n    avg_y <- movies %>% pull(input$y) %>% mean() %>% round(2)\n    paste(\"Average\", input$y, \"=\", avg_y)\n  })\n  \n  output$lmoutput <- renderPrint({\n    x <- movies %>% pull(input$x)\n    y <- movies %>% pull(input$y)\n    print(summary(lm(y ~ x, data = movies)), digits = 3, signif.stars = FALSE)\n  })\n  \n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n3.4.10 Practice - Creating and formatting HTML output\nIn the previous exercise you developed an app that reported averages of selected x and y variables as two separate outputs. An alternative approach would be to combine them into a single, multi-line output.\nCombine the values calculated in the previous exercise as described below to create a customized HTML output.\n\n3.4.10.1 Your turn\n\nIn the server, create a new output, named output$avgs, that replaces output$avg_x and output$avg_y. For this output, calculate avg_x and avg_y like you did before, save the output text strings as str_x and str_y, and finally combine these two text strings with HTML(paste(str_x, str_y, sep = '<br/>')).\nIn the UI, replace the textOutput()s with a call to htmlOutput(), calling the new HTML text string you created in the server.\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-4c Creating and formatting HTML output in your RStudio Workspace.\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    \n    sidebarPanel(\n      \n      selectInput(inputId = \"y\",\n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"audience_score\"),\n      \n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"critics_score\")\n      \n    ),\n    \n    mainPanel(\n      plotOutput(outputId = \"scatterplot\"),\n      textOutput(outputId = \"avg_x\"), # avg of x\n      textOutput(outputId = \"avg_y\"), # avg of y\n      verbatimTextOutput(outputId = \"lmoutput\") # regression output\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n  \n  output$avg_x <- renderText({\n    avg_x <- movies %>% pull(input$x) %>% mean() %>% round(2)\n    paste(\"Average\", input$x, \"=\", avg_x)\n  })\n  \n  output$avg_y <- renderText({\n    avg_y <- movies %>% pull(input$y) %>% mean() %>% round(2)\n    paste(\"Average\", input$y, \"=\", avg_y)\n  })\n  \n  output$lmoutput <- renderPrint({\n    x <- movies %>% pull(input$x)\n    y <- movies %>% pull(input$y)\n    print(summary(lm(y ~ x, data = movies)), digits = 3, signif.stars = FALSE)\n  })\n  \n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    \n    sidebarPanel(\n      \n      selectInput(inputId = \"y\",\n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"audience_score\"),\n      \n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"critics_score\")\n      \n    ),\n    \n    mainPanel(\n      plotOutput(outputId = \"scatterplot\"),\n      htmlOutput(outputId = \"avgs\"),\n      verbatimTextOutput(outputId = \"lmoutput\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  output$scatterplot <- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n  \n  output$avgs <- renderUI({\n    avg_x <- movies %>% pull(input$x) %>% mean() %>% round(2)\n    avg_y <- movies %>% pull(input$y) %>% mean() %>% round(2)\n    str_x <- paste(\"Average\", input$x, \"=\", avg_x)\n    str_y <- paste(\"Average\", input$y, \"=\", avg_y)\n    HTML(paste(str_x, str_y, sep = '<br/>'))\n  })\n  \n  output$lmoutput <- renderPrint({\n    x <- movies %>% pull(input$x)\n    y <- movies %>% pull(input$y)\n    print(summary(lm(y ~ x, data = movies)), digits = 3, signif.stars = FALSE)\n  })\n  \n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n3.4.11 Practice - Download data with downloadButton()\nIn this app you get to specify the filetype and the variables included in the file you will download. For downloading from a Shiny app we use the downloadHandler() function in the server and downloadButton() or downloadLink() function in the UI.\nDownload the selected data with downloadButton() using instructions help files to figure out exactly how it works\n\n3.4.11.1 Your turn\n\nIn the server function, add the name of the output for file download, the function for setting up a file download, and fill in other blanks. Looking in the help file for the function may be useful.\nIn the UI, add the name of the function for displaying a link or button for downloading.\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-4d Download data with downloadButton() in your RStudio Workspace.\n Go to RStudio Cloud Project\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    \n    sidebarPanel(\n      \n      radioButtons(inputId = \"filetype\",\n                   label = \"Select filetype:\",\n                   choices = c(\"csv\", \"tsv\"),\n                   selected = \"csv\"),\n      \n      checkboxGroupInput(inputId = \"selected_var\",\n                         label = \"Select variables:\",\n                         choices = names(movies),\n                         selected = c(\"title\"))\n      \n    ),\n    \n    mainPanel(\n      HTML(\"Select filetype and variables, then hit 'Download data'.\"),\n      ___(\"download_data\", \"Download data\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  # Download file\n  output$___ <- ___(\n    filename = function() {\n      paste0(\"movies.\", ___)\n    },\n    content = function(file) { \n      if(___ == \"csv\"){ \n        write_csv(movies %>% select(input$selected_var), file) \n      }\n      if(___ == \"tsv\"){ \n        write_tsv(movies %>% select(input$selected_var), file) \n      }\n    }\n  )\n  \n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\nShow solution\n\nSee the following code chunk for the solution to the exercise above.\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui <- fluidPage(\n  sidebarLayout(\n    \n    sidebarPanel(\n      \n      radioButtons(inputId = \"filetype\",\n                   label = \"Select filetype:\",\n                   choices = c(\"csv\", \"tsv\"),\n                   selected = \"csv\"),\n      \n      checkboxGroupInput(inputId = \"selected_var\",\n                         label = \"Select variables:\",\n                         choices = names(movies),\n                         selected = c(\"title\"))\n      \n    ),\n    \n    mainPanel(\n      HTML(\"Select filetype and variables, then hit 'Download data'.\"),\n      downloadButton(\"download_data\", \"Download data\")\n    )\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver <- function(input, output, session) {\n  \n  # Download file\n  output$download_data <- downloadHandler(\n    filename = function() {\n      paste0(\"movies.\", input$filetype)\n      },\n    content = function(file) { \n      if(input$filetype == \"csv\"){ \n        write_csv(movies %>% select(input$selected_var), file) \n        }\n      if(input$filetype == \"tsv\"){ \n        write_tsv(movies %>% select(input$selected_var), file) \n        }\n    }\n  )\n  \n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)"
  }
]